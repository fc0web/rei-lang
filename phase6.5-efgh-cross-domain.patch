From 2e7f104c4c6f6d9bfa2a07076dc212b92582214b Mon Sep 17 00:00:00 2001
From: Claude <claude@anthropic.com>
Date: Sat, 14 Feb 2026 22:57:38 +0000
Subject: [PATCH] =?UTF-8?q?Phase=206.5:=20EFGH=20cross-domain=20integratio?=
 =?UTF-8?q?n=20(E=E2=86=94F=E2=86=94G=E2=86=94H=20+=20EFGH=E2=86=92BCD=20b?=
 =?UTF-8?q?ridges=20+=207-domain=20universal=20composition)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- New: cross-domain-efgh.ts with 18 bridge functions
  - E↔F (art↔music): synesthesia mapping (color↔pitch)
  - E↔G (art↔economics): aesthetic value ↔ market
  - E↔H (art↔linguistics): pattern ↔ language description
  - F↔G (music↔economics): musical complexity ↔ market dynamics
  - F↔H (music↔linguistics): melody ↔ prosody
  - G↔H (economics↔linguistics): market state ↔ text
- New: EFGH→BCD bridges (art→sim, music→sim, market→sim, market→ethics, linguistics→humanities, linguistics→pipeline)
- New: compose_all for 7-domain (B-H) universal composition
- New: Universal σ (sigma) for cross-domain analysis
- Evaluator: 20 new pipe commands with Japanese aliases
- Tests: +99 (1459 total, all passing)
---
 package-lock.json                     |    4 +-
 src/lang/domains/cross-domain-efgh.ts | 1318 +++++++++++++++++++++++++
 src/lang/evaluator.ts                 |  108 +-
 tests/cross-domain-efgh.test.ts       |  785 +++++++++++++++
 4 files changed, 2212 insertions(+), 3 deletions(-)
 create mode 100644 src/lang/domains/cross-domain-efgh.ts
 create mode 100644 tests/cross-domain-efgh.test.ts

diff --git a/package-lock.json b/package-lock.json
index a15f157..967bd0e 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "rei-lang",
-  "version": "0.5.3",
+  "version": "0.5.4",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "rei-lang",
-      "version": "0.5.3",
+      "version": "0.5.4",
       "license": "Apache-2.0",
       "bin": {
         "rei": "bin/rei.js"
diff --git a/src/lang/domains/cross-domain-efgh.ts b/src/lang/domains/cross-domain-efgh.ts
new file mode 100644
index 0000000..fcc0dda
--- /dev/null
+++ b/src/lang/domains/cross-domain-efgh.ts
@@ -0,0 +1,1318 @@
+/**
+ * cross-domain-efgh.ts — EFGH ドメイン横断統合モジュール
+ * 
+ * 芸術(E)・音楽(F)・経済学(G)・言語学(H)の4新ドメインを
+ * 相互に連携させ、さらに既存B/C/Dドメインとも接続するブリッジ群。
+ * 
+ * ■ EFGH内部ブリッジ (12方向):
+ *   E↔F: 共感覚 — 色彩と音高の対応（シネスタジア）
+ *   E↔G: 美的価値 — 美学と市場価値の相互変換
+ *   E↔H: 視覚言語 — パターンと言語記述の対応
+ *   F↔G: 音響経済 — 音楽的複雑性と市場ダイナミクス
+ *   F↔H: 韻律言語 — 旋律と言語韻律の対応
+ *   G↔H: 経済言語 — 市場状態と言語的記述
+ * 
+ * ■ EFGH→BCD ブリッジ:
+ *   E→B: フラクタル→N体シミュレーション
+ *   F→B: リズム→波動シミュレーション
+ *   G→B: 市場エージェント→N体系
+ *   G→D: 市場行動→倫理分析
+ *   H→D: 構文解析→テキスト分析
+ *   H→C: 翻訳→データパイプライン
+ * 
+ * ■ 全ドメイン統合:
+ *   compose_all — 7ドメイン(B-H)の統合分析
+ * 
+ * D-FUMT哲学的基盤:
+ *   「縁起」の深化 — 芸術・音楽・経済・言語もまた
+ *   自然科学・情報工学・人文科学と不可分に結ばれている。
+ *   0₀式は全領域の中心-周囲構造を統一的に扱う。
+ * 
+ * @author Nobuki Fujimoto (D-FUMT)
+ * @version Phase 6.5 — EFGH ドメイン横断統合
+ */
+
+import {
+  colorHarmony, generateFractal, analyzeAesthetics,
+  type Color, type PatternResult, type ColorHarmony, type AestheticAnalysis,
+} from './art';
+
+import {
+  createScale, createChord, createMelody, createRhythm,
+  type ScaleResult, type ChordResult, type MelodyResult, type RhythmPattern, type Note,
+} from './music';
+
+import {
+  createMarket, marketRun, supplyDemand,
+  type MarketState, type GameTheoryResult, type SupplyDemandResult,
+} from './economics';
+
+import {
+  parseSyntax, createSemanticFrame, translate,
+  type SyntaxTree, type SemanticFrame, type TranslationResult, type WordRelation,
+} from './linguistics';
+
+import {
+  type SimulationSpace, type SimParticle,
+} from './simulation-core';
+
+import {
+  type PipelineSpace,
+  createPipelineSpace,
+} from './pipeline-core';
+
+import {
+  analyzeText, evaluateEthics,
+  type TextAnalysisResult, type EthicsResult,
+} from './humanities';
+
+import { composeDomains, type DomainComposition } from './cross-domain';
+
+// ============================================================
+// 型定義
+// ============================================================
+
+/** EFGH横断結果 */
+export interface EFGHCrossDomainResult {
+  reiType: 'EFGHCrossDomainResult';
+  source: { domain: string; type: string };
+  target: { domain: string; type: string };
+  bridge: string;
+  data: any;
+  metadata: {
+    sourceMetrics: Record<string, number>;
+    targetMetrics: Record<string, number>;
+    mappingQuality: number;
+    informationLoss: number;
+    synesthesia?: number;    // E↔F: 共感覚強度
+    aestheticValue?: number; // E↔G: 美的価値
+    prosody?: number;        // F↔H: 韻律度
+  };
+}
+
+/** 7ドメイン全体統合結果 */
+export interface UniversalComposition {
+  reiType: 'UniversalComposition';
+  domains: Record<string, { raw: any; metrics: Record<string, number> }>;
+  synthesis: {
+    commonPatterns: string[];
+    tensions: string[];
+    emergent: string | null;
+    harmony: number;
+    universality: number;  // 全ドメイン間の普遍性 (0-1)
+    domainCount: number;
+  };
+}
+
+// ============================================================
+// E→F: 芸術 → 音楽 (共感覚: 色彩→音高)
+// ============================================================
+
+/** 色彩調和を音階に変換（共感覚マッピング） */
+export function artToMusic(input: any): ScaleResult {
+  if (input?.reiType === 'ColorHarmony') {
+    const ch = input as ColorHarmony;
+    // Hue (0-360) → 12音名への対応 (Scriabin-inspired synesthesia)
+    const hueToNote = (h: number): string => {
+      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
+      return notes[Math.floor((h % 360) / 30)];
+    };
+    const root = hueToNote(ch.base.h);
+    // scheme → mode mapping
+    const modeMap: Record<string, string> = {
+      complementary: 'major',
+      analogous: 'pentatonic',
+      triadic: 'dorian',
+      'split-complementary': 'mixolydian',
+      tetradic: 'minor',
+    };
+    const mode = modeMap[ch.scheme] ?? 'major';
+    return createScale(root, mode);
+  }
+  
+  if (input?.reiType === 'PatternResult') {
+    const p = input as PatternResult;
+    // フラクタル複雑度 → 音階選択
+    const avgVal = p.data.flat().reduce((s, v) => s + v, 0) / Math.max(p.data.flat().length, 1);
+    const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
+    const root = notes[Math.floor(avgVal * 7) % 7];
+    const mode = avgVal > 0.6 ? 'minor' : avgVal > 0.3 ? 'dorian' : 'major';
+    return createScale(root, mode);
+  }
+  
+  if (input?.reiType === 'AestheticAnalysis') {
+    const a = input as AestheticAnalysis;
+    const warmth = a.scores.rhythm;
+    const root = warmth > 0.6 ? 'A' : warmth > 0.3 ? 'E' : 'C';
+    const mode = a.scores.complexity > 0.6 ? 'minor' : 'major';
+    return createScale(root, mode);
+  }
+  
+  // デフォルト: 数値→音階
+  const hue = typeof input === 'number' ? input : 0;
+  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
+  const root = notes[Math.floor((hue % 360) / 30)];
+  return createScale(root, 'major');
+}
+
+// ============================================================
+// F→E: 音楽 → 芸術 (共感覚: 音高→色彩)
+// ============================================================
+
+/** 音楽データを色彩調和に変換 */
+export function musicToArt(input: any): ColorHarmony {
+  // 音名 → Hue マッピング (Scriabin色聴)
+  const noteToHue = (name: string): number => {
+    const map: Record<string, number> = {
+      C: 0, 'C#': 30, D: 60, 'D#': 90, E: 120, F: 150,
+      'F#': 180, G: 210, 'G#': 240, A: 270, 'A#': 300, B: 330,
+    };
+    return map[name] ?? 0;
+  };
+  
+  if (input?.reiType === 'ScaleResult') {
+    const s = input as ScaleResult;
+    const hue = noteToHue(s.root);
+    const schemeMap: Record<string, string> = {
+      major: 'complementary', minor: 'analogous', dorian: 'triadic',
+      mixolydian: 'split-complementary', pentatonic: 'analogous',
+    };
+    return colorHarmony(hue, schemeMap[s.mode] ?? 'complementary');
+  }
+  
+  if (input?.reiType === 'ChordResult') {
+    const c = input as ChordResult;
+    const hue = noteToHue(c.root);
+    const scheme = c.consonance > 0.7 ? 'analogous' : 'complementary';
+    return colorHarmony(hue, scheme);
+  }
+  
+  if (input?.reiType === 'MelodyResult') {
+    const m = input as MelodyResult;
+    const rootHue = m.notes.length > 0 ? noteToHue(m.notes[0].name) : 0;
+    const scheme = m.resolution > 0.6 ? 'analogous' : 'triadic';
+    return colorHarmony(rootHue, scheme);
+  }
+  
+  // デフォルト
+  return colorHarmony(0, 'complementary');
+}
+
+// ============================================================
+// E→G: 芸術 → 経済学 (美的価値 → 市場)
+// ============================================================
+
+/** 美学分析から市場価値を推定 */
+export function artToMarket(input: any): MarketState {
+  let basePrice = 100;
+  let volatility = 0.3;
+  let name = 'art_market';
+  
+  if (input?.reiType === 'AestheticAnalysis') {
+    const a = input as AestheticAnalysis;
+    // 美的スコアが高いほど価格が高い
+    basePrice = 50 + a.overallBeauty * 200;
+    volatility = 1 - a.scores.unity;  // 統一感が低いほどボラティリティ高
+    name = `art_market_${a.style}`;
+  } else if (input?.reiType === 'ColorHarmony') {
+    const ch = input as ColorHarmony;
+    basePrice = 80 + ch.harmony * 120;
+    volatility = 1 - ch.harmony;
+    name = `color_market_${ch.scheme}`;
+  } else if (input?.reiType === 'PatternResult') {
+    const p = input as PatternResult;
+    basePrice = 60 + (p.iterations / 100) * 140;
+    volatility = 0.4;
+    name = `pattern_market_${p.type}`;
+  }
+  
+  return createMarket(name, basePrice, 8);
+}
+
+// ============================================================
+// G→E: 経済学 → 芸術 (市場データ → 視覚パターン)
+// ============================================================
+
+/** 市場の価格履歴をフラクタルパターンに変換 */
+export function marketToArt(input: any): PatternResult {
+  if (input?.reiType === 'MarketState') {
+    const m = input as MarketState;
+    const size = Math.max(10, Math.min(30, m.history.length));
+    // 価格履歴をフラクタルの初期値にマッピング
+    const fractal = generateFractal(size, size, 30);
+    // 市場データを重ね合わせ
+    if (m.history.length > 0) {
+      for (let y = 0; y < Math.min(fractal.height, m.history.length); y++) {
+        const priceNorm = (m.history[y].price - m.history[0].price) / (Math.abs(m.history[0].price) + 1);
+        for (let x = 0; x < fractal.width; x++) {
+          fractal.data[y][x] = Math.max(0, Math.min(1,
+            fractal.data[y][x] * 0.6 + Math.abs(priceNorm) * 0.4
+          ));
+        }
+      }
+    }
+    fractal.params.sourceDomain = 'economics';
+    fractal.params.marketName = m.name;
+    fractal.params.trend = m.trend;
+    return fractal;
+  }
+  
+  // SupplyDemand → パターン
+  if (input?.reiType === 'SupplyDemandResult') {
+    const sd = input as SupplyDemandResult;
+    const fractal = generateFractal(20, 20, 30);
+    fractal.params.sourceDomain = 'economics';
+    fractal.params.equilibrium = sd.equilibrium;
+    return fractal;
+  }
+  
+  return generateFractal(20, 20, 30);
+}
+
+// ============================================================
+// E→H: 芸術 → 言語学 (パターン → 言語記述)
+// ============================================================
+
+/** 芸術作品を言語的に記述 */
+export function artToText(input: any): SyntaxTree {
+  let description = '';
+  
+  if (input?.reiType === 'AestheticAnalysis') {
+    const a = input as AestheticAnalysis;
+    const adj = a.overallBeauty > 0.7 ? '美しい' : a.overallBeauty > 0.4 ? '興味深い' : '素朴な';
+    description = `${adj}${a.style}の作品を分析した`;
+  } else if (input?.reiType === 'ColorHarmony') {
+    const ch = input as ColorHarmony;
+    const temp = ch.warmth > 0 ? '暖かい' : '冷たい';
+    description = `${temp}${ch.scheme}の色彩調和を構成した`;
+  } else if (input?.reiType === 'PatternResult') {
+    const p = input as PatternResult;
+    description = `${p.type}パターンを${p.iterations}回反復で生成した`;
+  } else {
+    description = '芸術的表現を言語に変換した';
+  }
+  
+  return parseSyntax(description);
+}
+
+// ============================================================
+// H→E: 言語学 → 芸術 (テキスト → 色彩)
+// ============================================================
+
+/** テキストの感情から色彩調和を生成 */
+export function textToArt(input: any): ColorHarmony {
+  let hue = 180;  // デフォルト: シアン
+  let scheme = 'analogous';
+  
+  if (input?.reiType === 'SyntaxTree') {
+    const st = input as SyntaxTree;
+    // 文の長さ・複雑度から色相を決定
+    hue = (st.depth * 47 + st.nodeCount * 23) % 360;
+    scheme = st.depth > 4 ? 'triadic' : 'analogous';
+  } else if (input?.reiType === 'SemanticFrame') {
+    const sf = input as SemanticFrame;
+    // 極性 → 暖色系/寒色系
+    hue = sf.polarity === 'positive' ? 30 : 210;  // 暖色 vs 寒色
+    scheme = sf.roles.length > 2 ? 'triadic' : 'complementary';
+  } else if (input?.reiType === 'TranslationResult') {
+    const tr = input as TranslationResult;
+    hue = (tr.confidence * 360) % 360;
+    scheme = tr.glosses.length > 3 ? 'tetradic' : 'complementary';
+  } else if (input?.reiType === 'WordRelation') {
+    const wr = input as WordRelation;
+    hue = (wr.relations.length * 60) % 360;
+    scheme = 'analogous';
+  }
+  
+  return colorHarmony(hue, scheme);
+}
+
+// ============================================================
+// F→G: 音楽 → 経済学 (音楽的複雑性 → 市場モデル)
+// ============================================================
+
+/** 音楽的特性から市場を生成 */
+export function musicToMarket(input: any): MarketState {
+  let price = 100;
+  let agents = 10;
+  let name = 'music_market';
+  
+  if (input?.reiType === 'ScaleResult') {
+    const s = input as ScaleResult;
+    price = 80 + s.tension * 40;
+    agents = s.notes.length;
+    name = `scale_market_${s.mode}`;
+  } else if (input?.reiType === 'MelodyResult') {
+    const m = input as MelodyResult;
+    price = 80 + m.range * 2;
+    agents = Math.max(5, m.notes.length);
+    name = 'melody_market';
+  } else if (input?.reiType === 'RhythmPattern') {
+    const r = input as RhythmPattern;
+    price = 80 + r.complexity * 40;
+    agents = Math.max(5, r.pattern.length);
+    name = `rhythm_market_bpm${r.bpm}`;
+  } else if (input?.reiType === 'ChordResult') {
+    const c = input as ChordResult;
+    price = 80 + c.consonance * 40;
+    agents = c.notes.length + 5;
+    name = `chord_market_${c.type}`;
+  }
+  
+  return createMarket(name, price, Math.min(agents, 20));
+}
+
+// ============================================================
+// G→F: 経済学 → 音楽 (市場データ → 旋律: ソニフィケーション)
+// ============================================================
+
+/** 市場の価格履歴を旋律に変換（ソニフィケーション） */
+export function marketToMusic(input: any): MelodyResult | ScaleResult {
+  if (input?.reiType === 'MarketState') {
+    const m = input as MarketState;
+    // trend → 音階の気分
+    const mode = m.trend === 'bull' ? 'major' : m.trend === 'bear' ? 'minor' : 'dorian';
+    const scale = createScale('C', mode);
+    
+    if (m.history.length >= 2) {
+      // 価格履歴を旋律に変換
+      const style = m.volatility > 0.5 ? 'leap' : 'stepwise';
+      const length = Math.min(Math.max(m.history.length, 4), 16);
+      return createMelody(scale, length, style);
+    }
+    return scale;
+  }
+  
+  if (input?.reiType === 'SupplyDemandResult') {
+    const sd = input as SupplyDemandResult;
+    // 均衡が高い → 高い音域の音階
+    const root = sd.equilibrium.price > 50 ? 'G' : 'C';
+    return createScale(root, 'major');
+  }
+  
+  if (input?.reiType === 'GameTheoryResult') {
+    const gt = input as GameTheoryResult;
+    // 協力度 → 音階の気分
+    const mode = gt.cooperationIndex > 0.5 ? 'major' : 'minor';
+    return createScale('D', mode);
+  }
+  
+  return createScale('C', 'major');
+}
+
+// ============================================================
+// F→H: 音楽 → 言語学 (旋律 → 言語記述)
+// ============================================================
+
+/** 音楽を言語的に記述 */
+export function musicToText(input: any): SyntaxTree {
+  let description = '';
+  
+  if (input?.reiType === 'ScaleResult') {
+    const s = input as ScaleResult;
+    const mood = s.tension > 0.5 ? '緊張感のある' : '安定した';
+    description = `${mood}${s.root}${s.mode}の音階を構築した`;
+  } else if (input?.reiType === 'MelodyResult') {
+    const m = input as MelodyResult;
+    const shape = m.contour === 'ascending' ? '上昇する' : m.contour === 'descending' ? '下降する' : '変化する';
+    description = `${shape}旋律を${m.notes.length}音で紡いだ`;
+  } else if (input?.reiType === 'ChordResult') {
+    const c = input as ChordResult;
+    const quality = c.consonance > 0.7 ? '協和的な' : '不協和な';
+    description = `${quality}${c.root}${c.type}の和音を鳴らした`;
+  } else if (input?.reiType === 'RhythmPattern') {
+    const r = input as RhythmPattern;
+    const feel = r.groove > 0.5 ? 'グルーヴ感のある' : 'タイトな';
+    description = `${feel}リズムをBPM${r.bpm}で刻んだ`;
+  } else {
+    description = '音楽的表現を言語に変換した';
+  }
+  
+  return parseSyntax(description);
+}
+
+// ============================================================
+// H→F: 言語学 → 音楽 (テキスト → 音楽: 韻律マッピング)
+// ============================================================
+
+/** テキストの韻律を音楽に変換 */
+export function textToMusic(input: any): ScaleResult {
+  if (input?.reiType === 'SyntaxTree') {
+    const st = input as SyntaxTree;
+    // 文構造 → 音階
+    const structureMap: Record<string, string> = {
+      SVO: 'major', SOV: 'pentatonic', VSO: 'dorian',
+    };
+    const mode = structureMap[st.structure] ?? 'major';
+    // 深さ → ルート音
+    const roots = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
+    const root = roots[st.depth % roots.length];
+    return createScale(root, mode);
+  }
+  
+  if (input?.reiType === 'SemanticFrame') {
+    const sf = input as SemanticFrame;
+    // モダリティ → 音階
+    const modeMap: Record<string, string> = {
+      declarative: 'major', interrogative: 'dorian',
+      imperative: 'mixolydian', subjunctive: 'minor',
+    };
+    return createScale('C', modeMap[sf.modality] ?? 'major');
+  }
+  
+  if (input?.reiType === 'TranslationResult') {
+    const tr = input as TranslationResult;
+    const root = tr.source.lang === 'ja' ? 'D' : 'C';
+    return createScale(root, tr.confidence > 0.7 ? 'major' : 'minor');
+  }
+  
+  return createScale('C', 'major');
+}
+
+// ============================================================
+// G→H: 経済学 → 言語学 (市場状態 → テキスト記述)
+// ============================================================
+
+/** 市場状態を言語的に記述 */
+export function marketToText(input: any): SyntaxTree {
+  let description = '';
+  
+  if (input?.reiType === 'MarketState') {
+    const m = input as MarketState;
+    const trend = m.trend === 'bull' ? '上昇' : m.trend === 'bear' ? '下落' : '安定';
+    description = `${m.name}市場は${trend}傾向で価格は${m.price.toFixed(0)}である`;
+  } else if (input?.reiType === 'SupplyDemandResult') {
+    const sd = input as SupplyDemandResult;
+    description = `需給均衡点は価格${sd.equilibrium.price.toFixed(1)}数量${sd.equilibrium.quantity.toFixed(1)}である`;
+  } else if (input?.reiType === 'GameTheoryResult') {
+    const gt = input as GameTheoryResult;
+    const coop = gt.cooperationIndex > 0.5 ? '協力的' : '競争的';
+    description = `${gt.game}は${coop}なゲーム構造を持つ`;
+  } else {
+    description = '経済的分析結果を言語に変換した';
+  }
+  
+  return parseSyntax(description);
+}
+
+// ============================================================
+// H→G: 言語学 → 経済学 (テキスト感情 → 市場エージェント)
+// ============================================================
+
+/** テキスト分析から市場を生成 */
+export function textToMarket(input: any): MarketState {
+  let price = 100;
+  let agents = 10;
+  let name = 'text_market';
+  
+  if (input?.reiType === 'SyntaxTree') {
+    const st = input as SyntaxTree;
+    price = 80 + st.depth * 10;
+    agents = Math.max(5, Math.min(st.nodeCount, 20));
+    name = `syntax_market_${st.structure}`;
+  } else if (input?.reiType === 'SemanticFrame') {
+    const sf = input as SemanticFrame;
+    price = sf.polarity === 'positive' ? 120 : 80;
+    agents = Math.max(5, sf.roles.length + 5);
+    name = `semantic_market_${sf.modality}`;
+  } else if (input?.reiType === 'TranslationResult') {
+    const tr = input as TranslationResult;
+    price = 80 + tr.confidence * 40;
+    agents = Math.max(5, tr.glosses.length + 3);
+    name = `translation_market_${tr.source.lang}_${tr.target.lang}`;
+  }
+  
+  return createMarket(name, price, agents);
+}
+
+// ============================================================
+// EFGH → BCD ブリッジ
+// ============================================================
+
+/** E→B: フラクタルパターン → N体シミュレーション */
+export function artToSim(input: any): SimulationSpace {
+  const particles: SimParticle[] = [];
+  
+  if (input?.reiType === 'PatternResult') {
+    const p = input as PatternResult;
+    // パターンの高値点を粒子化
+    let count = 0;
+    for (let y = 0; y < p.height && count < 15; y += Math.max(1, Math.floor(p.height / 5))) {
+      for (let x = 0; x < p.width && count < 15; x += Math.max(1, Math.floor(p.width / 5))) {
+        const val = p.data[y]?.[x] ?? 0;
+        if (val > 0.3) {
+          particles.push({
+            id: `art_p${count}`,
+            position: [x * 0.5, y * 0.5],
+            velocity: [0, 0],
+            mass: val * 2 + 0.5,
+            properties: { fractalValue: val },
+          });
+          count++;
+        }
+      }
+    }
+  } else if (input?.reiType === 'ColorHarmony') {
+    const ch = input as ColorHarmony;
+    ch.colors.forEach((c, i) => {
+      const angle = (2 * Math.PI * i) / ch.colors.length;
+      particles.push({
+        id: `color_p${i}`,
+        position: [3 * Math.cos(angle), 3 * Math.sin(angle)],
+        velocity: [0, 0],
+        mass: (c.l / 100) + 0.5,
+        properties: { r: c.r, g: c.g, b: c.b },
+      });
+    });
+  }
+  
+  // 最低3粒子を確保
+  while (particles.length < 3) {
+    particles.push({
+      id: `fill_p${particles.length}`,
+      position: [particles.length * 1.5, 0],
+      velocity: [0, 0],
+      mass: 1,
+      properties: {},
+    });
+  }
+  
+  return {
+    reiType: 'SimulationSpace',
+    domain: 'general',
+    particles,
+    rules: [],
+    time: 0,
+    dt: 0.01,
+    dimensions: 2,
+    history: [],
+    params: {},
+    
+  } as SimulationSpace;
+}
+
+/** F→B: 音楽 → 波動シミュレーション */
+export function musicToSim(input: any): SimulationSpace {
+  const particles: SimParticle[] = [];
+  
+  if (input?.reiType === 'ScaleResult') {
+    const s = input as ScaleResult;
+    s.notes.forEach((note, i) => {
+      particles.push({
+        id: `note_p${i}`,
+        position: [i * 1.0, 0],
+        velocity: [0, note.frequency / 1000],
+        mass: 1,
+        properties: { frequency: note.frequency, midi: note.midi },
+      });
+    });
+  } else if (input?.reiType === 'MelodyResult') {
+    const m = input as MelodyResult;
+    m.notes.forEach((note, i) => {
+      particles.push({
+        id: `melody_p${i}`,
+        position: [i * 0.5, note.midi / 127 * 5],
+        velocity: [0.1, 0],
+        mass: 1,
+        properties: { frequency: note.frequency },
+      });
+    });
+  } else if (input?.reiType === 'RhythmPattern') {
+    const r = input as RhythmPattern;
+    r.pattern.forEach((beat, i) => {
+      if (beat > 0) {
+        particles.push({
+          id: `beat_p${i}`,
+          position: [i * 0.8, 0],
+          velocity: [0, beat * 2],
+          mass: beat + 0.5,
+          properties: { beatValue: beat },
+        });
+      }
+    });
+  }
+  
+  while (particles.length < 3) {
+    particles.push({
+      id: `fill_p${particles.length}`,
+      position: [particles.length * 1.5, 0],
+      velocity: [0, 0],
+      mass: 1,
+      properties: {},
+    });
+  }
+  
+  return {
+    reiType: 'SimulationSpace',
+    domain: 'general',
+    particles,
+    rules: [],
+    time: 0,
+    dt: 0.01,
+    dimensions: 2,
+    history: [],
+    params: {},
+    
+  } as SimulationSpace;
+}
+
+/** G→B: 市場エージェント → N体系 */
+export function marketToSim(input: any): SimulationSpace {
+  const particles: SimParticle[] = [];
+  
+  if (input?.reiType === 'MarketState') {
+    const m = input as MarketState;
+    m.agents.forEach((agent, i) => {
+      const angle = (2 * Math.PI * i) / m.agents.length;
+      particles.push({
+        id: agent.id,
+        position: [3 * Math.cos(angle), 3 * Math.sin(angle)],
+        velocity: [
+          agent.type === 'buyer' ? 0.1 : agent.type === 'seller' ? -0.1 : 0,
+          0,
+        ],
+        mass: agent.capital / 100 + 0.5,
+        properties: {
+          type: agent.type === 'buyer' ? 1 : agent.type === 'seller' ? -1 : 0,
+          capital: agent.capital,
+          inventory: agent.inventory,
+        },
+      });
+    });
+  }
+  
+  while (particles.length < 3) {
+    particles.push({
+      id: `fill_p${particles.length}`,
+      position: [particles.length * 1.5, 0],
+      velocity: [0, 0],
+      mass: 1,
+      properties: {},
+    });
+  }
+  
+  return {
+    reiType: 'SimulationSpace',
+    domain: 'general',
+    particles,
+    rules: [],
+    time: 0,
+    dt: 0.01,
+    dimensions: 2,
+    history: [],
+    params: {},
+    
+  } as SimulationSpace;
+}
+
+/** G→D: 市場行動の倫理的評価 */
+export function marketEthics(input: any): EthicsResult {
+  let action = '市場取引';
+  
+  if (input?.reiType === 'MarketState') {
+    const m = input as MarketState;
+    action = `${m.name}市場での取引 (価格:${m.price.toFixed(0)}, 参加者:${m.agents.length}人, 傾向:${m.trend})`;
+  } else if (input?.reiType === 'GameTheoryResult') {
+    const gt = input as GameTheoryResult;
+    action = `${gt.game}: ${gt.players.join(' vs ')} の戦略的意思決定`;
+  }
+  
+  return evaluateEthics(action, ['utilitarian', 'deontological', 'virtue', 'justice']);
+}
+
+/** H→D: 構文解析 → テキスト分析 */
+export function linguisticsToHumanities(input: any): TextAnalysisResult {
+  let text = '';
+  
+  if (input?.reiType === 'SyntaxTree') {
+    text = (input as SyntaxTree).sentence;
+  } else if (input?.reiType === 'TranslationResult') {
+    text = (input as TranslationResult).target.text;
+  } else if (input?.reiType === 'SemanticFrame') {
+    const sf = input as SemanticFrame;
+    text = `${sf.predicate}: ${sf.roles.map(r => `${r.role}=${r.filler}`).join(', ')}`;
+  } else if (input?.reiType === 'WordRelation') {
+    const wr = input as WordRelation;
+    text = `${wr.word}: ${wr.relations.map(r => `${r.type}(${r.words.join(',')})`).join(' ')}`;
+  } else {
+    text = String(input);
+  }
+  
+  const result = analyzeText(text);
+  (result as any).metadata = {
+    sourceDomain: 'linguistics',
+    bridge: 'linguistics_to_humanities',
+  };
+  return result;
+}
+
+/** H→C: 翻訳結果 → データパイプライン */
+export function linguisticsToPipeline(input: any): PipelineSpace {
+  let records: any[] = [];
+  
+  if (input?.reiType === 'TranslationResult') {
+    const tr = input as TranslationResult;
+    records = tr.glosses.map(g => ({
+      source: g.source,
+      target: g.target,
+      pos: g.pos,
+    }));
+  } else if (input?.reiType === 'SyntaxTree') {
+    const st = input as SyntaxTree;
+    // 構文木のノードをフラット化
+    const flatten = (node: any, depth: number = 0): any[] => {
+      const items: any[] = [{ type: node.type, value: node.value ?? '', depth }];
+      for (const child of (node.children ?? [])) {
+        items.push(...flatten(child, depth + 1));
+      }
+      return items;
+    };
+    records = flatten(st.root);
+  } else if (input?.reiType === 'WordRelation') {
+    const wr = input as WordRelation;
+    records = wr.relations.flatMap(r => 
+      r.words.map(w => ({ word: wr.word, relation: r.type, related: w }))
+    );
+  }
+  
+  if (records.length === 0) {
+    records = [{ data: String(input) }];
+  }
+  
+  const pipeline = createPipelineSpace(records);
+  pipeline.metadata.sourceDomain = 'linguistics';
+  pipeline.metadata.bridge = 'linguistics_to_pipeline';
+  return pipeline;
+}
+
+// ============================================================
+// 7ドメイン全体統合
+// ============================================================
+
+/** 全ドメイン(B-H)の統合分析 */
+export function composeAll(inputs: Record<string, any>): UniversalComposition {
+  const domainNames = [
+    'natural_science', 'info_engineering', 'humanities',
+    'art', 'music', 'economics', 'linguistics',
+  ];
+  const domainLabels = ['B', 'C', 'D', 'E', 'F', 'G', 'H'];
+  
+  const domains: Record<string, { raw: any; metrics: Record<string, number> }> = {};
+  
+  for (let i = 0; i < domainNames.length; i++) {
+    const key = domainNames[i];
+    const label = domainLabels[i];
+    const raw = inputs[key] ?? inputs[label] ?? inputs[key.split('_').join('_')] ?? null;
+    domains[key] = {
+      raw,
+      metrics: raw ? extractUniversalMetrics(raw) : emptyMetrics(),
+    };
+  }
+  
+  // 共通パターンの検出
+  const commonPatterns: string[] = [];
+  const activeDomains = Object.entries(domains).filter(([_, v]) => v.raw !== null);
+  
+  // 複雑性分析
+  const complexities = activeDomains.map(([_, v]) => v.metrics.complexity);
+  const avgComplexity = complexities.length > 0 
+    ? complexities.reduce((a, b) => a + b, 0) / complexities.length : 0;
+  if (avgComplexity > 0.5) commonPatterns.push('高複雑性');
+  
+  // 調和性分析
+  const harmonies = activeDomains.map(([_, v]) => v.metrics.harmony);
+  const avgHarmony = harmonies.length > 0
+    ? harmonies.reduce((a, b) => a + b, 0) / harmonies.length : 0;
+  if (avgHarmony > 0.6) commonPatterns.push('高調和性');
+  
+  // ネットワーク構造
+  const densities = activeDomains.map(([_, v]) => v.metrics.networkDensity);
+  if (densities.filter(d => d > 0.3).length >= 3) {
+    commonPatterns.push('ネットワーク構造の類似性');
+  }
+  
+  // エネルギー/情報の流れ
+  const flows = activeDomains.map(([_, v]) => v.metrics.flow);
+  if (flows.filter(f => f > 0.3).length >= 3) {
+    commonPatterns.push('エネルギー/情報の流れ');
+  }
+  
+  // 創造性
+  const creativities = activeDomains.map(([_, v]) => v.metrics.creativity);
+  if (creativities.filter(c => c > 0.4).length >= 2) {
+    commonPatterns.push('創造的パターン');
+  }
+  
+  // 緊張関係の検出
+  const tensions: string[] = [];
+  
+  const artMetrics = domains.art.metrics;
+  const ecoMetrics = domains.economics.metrics;
+  const sciMetrics = domains.natural_science.metrics;
+  const humMetrics = domains.humanities.metrics;
+  
+  if (artMetrics.creativity > 0.5 && ecoMetrics.efficiency > 0.5) {
+    tensions.push('創造性 vs 効率性');
+  }
+  if (sciMetrics.determinism > 0.6 && artMetrics.freedom > 0.5) {
+    tensions.push('決定論 vs 芸術的自由');
+  }
+  if (ecoMetrics.competition > 0.5 && humMetrics.ethicalScore > 0.5) {
+    tensions.push('競争 vs 倫理的配慮');
+  }
+  
+  // 創発的洞察
+  let emergent: string | null = null;
+  if (activeDomains.length >= 5 && commonPatterns.length >= 3) {
+    emergent = '全ドメインの統合から普遍的構造が創発 — 0₀式の中心-周囲構造';
+  } else if (activeDomains.length >= 4 && commonPatterns.length >= 2 && tensions.length >= 1) {
+    emergent = '多領域の相互作用から新たな秩序が創発';
+  } else if (commonPatterns.length >= 2) {
+    emergent = '共通パターンの発見 — 領域を超えた構造的類似性';
+  } else if (tensions.length >= 2) {
+    emergent = '弁証法的統合の必要性 — 対立の調和へ';
+  }
+  
+  // 調和度・普遍性
+  const allValues = activeDomains.flatMap(([_, v]) => Object.values(v.metrics)).filter(v => typeof v === 'number');
+  const mean = allValues.length > 0 ? allValues.reduce((a, b) => a + b, 0) / allValues.length : 0;
+  const variance = allValues.length > 0
+    ? allValues.reduce((s, v) => s + (v - mean) ** 2, 0) / allValues.length : 0;
+  const harmony = Math.max(0, 1 - Math.sqrt(variance));
+  const universality = activeDomains.length >= 5
+    ? Math.min(1, (commonPatterns.length / 4) * harmony) : commonPatterns.length / 5;
+  
+  return {
+    reiType: 'UniversalComposition',
+    domains,
+    synthesis: {
+      commonPatterns,
+      tensions,
+      emergent,
+      harmony,
+      universality,
+      domainCount: activeDomains.length,
+    },
+  };
+}
+
+// ============================================================
+// ヘルパー
+// ============================================================
+
+function emptyMetrics(): Record<string, number> {
+  return {
+    complexity: 0, harmony: 0, networkDensity: 0, flow: 0,
+    creativity: 0, determinism: 0.5, freedom: 0.5,
+    efficiency: 0.5, ethicalScore: 0.5, competition: 0.5,
+  };
+}
+
+function extractUniversalMetrics(data: any): Record<string, number> {
+  if (!data || typeof data !== 'object') return emptyMetrics();
+  
+  const reiType = data.reiType ?? '';
+  
+  // SimulationSpace (B)
+  if (reiType === 'SimulationSpace') {
+    const n = data.particles?.length ?? 0;
+    return {
+      complexity: Math.min(n / 10, 1),
+      harmony: 0.5,
+      networkDensity: Math.min(n * (n - 1) / 20, 1),
+      flow: 0.5,
+      creativity: 0.2,
+      determinism: 0.8,
+      freedom: 0.2,
+      efficiency: 0.6,
+      ethicalScore: 0.5,
+      competition: 0.3,
+    };
+  }
+  
+  // PipelineSpace (C)
+  if (reiType === 'PipelineSpace') {
+    const nStages = data.stages?.length ?? 0;
+    return {
+      complexity: Math.min(nStages / 5, 1),
+      harmony: 0.7,
+      networkDensity: 0.3,
+      flow: data.status === 'completed' ? 0.9 : 0.3,
+      creativity: 0.2,
+      determinism: 0.9,
+      freedom: 0.1,
+      efficiency: data.status === 'completed' ? 0.8 : 0.4,
+      ethicalScore: 0.6,
+      competition: 0.2,
+    };
+  }
+  
+  // TextAnalysis / EthicsResult (D)
+  if (reiType === 'TextAnalysis') {
+    return {
+      complexity: Math.min((data.stats?.entropy ?? 0) / 5, 1),
+      harmony: 0.5,
+      networkDensity: data.stats?.diversity ?? 0.5,
+      flow: 0.5,
+      creativity: 0.5,
+      determinism: 0.3,
+      freedom: 0.7,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.3,
+    };
+  }
+  if (reiType === 'EthicsResult') {
+    return {
+      complexity: (data.perspectives?.length ?? 0) / 5,
+      harmony: data.synthesis?.consensus ? 0.8 : 0.3,
+      networkDensity: 0.5,
+      flow: 0.5,
+      creativity: 0.3,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: Math.max(0, Math.min(1, ((data.synthesis?.overallScore ?? 0) + 1) / 2)),
+      competition: 0.3,
+    };
+  }
+  
+  // PatternResult / ColorHarmony / AestheticAnalysis (E)
+  if (reiType === 'PatternResult') {
+    const p = data as PatternResult;
+    return {
+      complexity: Math.min(p.iterations / 100, 1),
+      harmony: 0.6,
+      networkDensity: 0.4,
+      flow: 0.5,
+      creativity: 0.8,
+      determinism: 0.6,
+      freedom: 0.7,
+      efficiency: 0.4,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  if (reiType === 'ColorHarmony') {
+    const ch = data as ColorHarmony;
+    return {
+      complexity: ch.colors.length / 5,
+      harmony: ch.harmony,
+      networkDensity: 0.5,
+      flow: 0.4,
+      creativity: 0.9,
+      determinism: 0.3,
+      freedom: 0.8,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  if (reiType === 'AestheticAnalysis') {
+    const a = data as AestheticAnalysis;
+    return {
+      complexity: a.scores.complexity,
+      harmony: (a.scores.balance + a.scores.unity) / 2,
+      networkDensity: 0.4,
+      flow: a.scores.rhythm,
+      creativity: a.overallBeauty,
+      determinism: 0.3,
+      freedom: 0.8,
+      efficiency: 0.4,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  
+  // ScaleResult / ChordResult / MelodyResult / RhythmPattern (F)
+  if (reiType === 'ScaleResult') {
+    const s = data as ScaleResult;
+    return {
+      complexity: s.notes.length / 12,
+      harmony: 1 - s.tension,
+      networkDensity: 0.4,
+      flow: 0.6,
+      creativity: 0.7,
+      determinism: 0.5,
+      freedom: 0.6,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  if (reiType === 'ChordResult') {
+    const c = data as ChordResult;
+    return {
+      complexity: c.notes.length / 5,
+      harmony: c.consonance,
+      networkDensity: 0.5,
+      flow: 0.5,
+      creativity: 0.6,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  if (reiType === 'MelodyResult') {
+    const m = data as MelodyResult;
+    return {
+      complexity: Math.min(m.range / 24, 1),
+      harmony: m.resolution,
+      networkDensity: 0.3,
+      flow: 0.7,
+      creativity: 0.8,
+      determinism: 0.4,
+      freedom: 0.7,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  if (reiType === 'RhythmPattern') {
+    const r = data as RhythmPattern;
+    return {
+      complexity: r.complexity,
+      harmony: r.groove,
+      networkDensity: 0.3,
+      flow: 0.8,
+      creativity: 0.6,
+      determinism: 0.6,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.1,
+    };
+  }
+  
+  // MarketState / SupplyDemandResult / GameTheoryResult (G)
+  if (reiType === 'MarketState') {
+    const m = data as MarketState;
+    return {
+      complexity: Math.min(m.agents.length / 20, 1),
+      harmony: m.trend === 'stable' ? 0.7 : 0.3,
+      networkDensity: Math.min(m.agents.length / 10, 1),
+      flow: 0.6,
+      creativity: 0.3,
+      determinism: 0.4,
+      freedom: 0.5,
+      efficiency: 0.7,
+      ethicalScore: 0.5,
+      competition: 0.8,
+    };
+  }
+  if (reiType === 'SupplyDemandResult') {
+    return {
+      complexity: 0.4,
+      harmony: 0.6,
+      networkDensity: 0.3,
+      flow: 0.5,
+      creativity: 0.2,
+      determinism: 0.7,
+      freedom: 0.3,
+      efficiency: 0.8,
+      ethicalScore: 0.5,
+      competition: 0.6,
+    };
+  }
+  if (reiType === 'GameTheoryResult') {
+    const gt = data as GameTheoryResult;
+    return {
+      complexity: Math.min(gt.players.length / 4, 1),
+      harmony: gt.cooperationIndex,
+      networkDensity: 0.6,
+      flow: 0.4,
+      creativity: 0.3,
+      determinism: 0.6,
+      freedom: 0.4,
+      efficiency: 0.6,
+      ethicalScore: gt.cooperationIndex,
+      competition: 1 - gt.cooperationIndex,
+    };
+  }
+  
+  // SyntaxTree / SemanticFrame / TranslationResult / WordRelation (H)
+  if (reiType === 'SyntaxTree') {
+    const st = data as SyntaxTree;
+    return {
+      complexity: Math.min(st.depth / 8, 1),
+      harmony: 0.5,
+      networkDensity: Math.min(st.nodeCount / 20, 1),
+      flow: 0.5,
+      creativity: 0.4,
+      determinism: 0.6,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.2,
+    };
+  }
+  if (reiType === 'SemanticFrame') {
+    const sf = data as SemanticFrame;
+    return {
+      complexity: Math.min(sf.roles.length / 5, 1),
+      harmony: sf.polarity === 'positive' ? 0.7 : 0.3,
+      networkDensity: Math.min(sf.roles.length / 4, 1),
+      flow: 0.5,
+      creativity: 0.4,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: 0.6,
+      ethicalScore: 0.5,
+      competition: 0.2,
+    };
+  }
+  if (reiType === 'TranslationResult') {
+    const tr = data as TranslationResult;
+    return {
+      complexity: Math.min(tr.glosses.length / 10, 1),
+      harmony: tr.confidence,
+      networkDensity: 0.4,
+      flow: 0.6,
+      creativity: 0.5,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: tr.confidence,
+      ethicalScore: 0.5,
+      competition: 0.2,
+    };
+  }
+  if (reiType === 'WordRelation') {
+    const wr = data as WordRelation;
+    return {
+      complexity: Math.min(wr.relations.length / 6, 1),
+      harmony: 0.5,
+      networkDensity: Math.min(wr.relations.reduce((s, r) => s + r.words.length, 0) / 10, 1),
+      flow: 0.4,
+      creativity: 0.4,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.2,
+    };
+  }
+  
+  // GraphSpace
+  if (reiType === 'GraphSpace') {
+    const nNodes = data.nodes?.size ?? 0;
+    const nEdges = data.edges?.length ?? 0;
+    return {
+      complexity: Math.min(nNodes / 10, 1),
+      harmony: 0.5,
+      networkDensity: nNodes > 1 ? Math.min(nEdges / (nNodes * (nNodes - 1) / 2), 1) : 0,
+      flow: 0.5,
+      creativity: 0.3,
+      determinism: 0.5,
+      freedom: 0.5,
+      efficiency: 0.5,
+      ethicalScore: 0.5,
+      competition: 0.3,
+    };
+  }
+  
+  return emptyMetrics();
+}
+
+// ============================================================
+// σ (シグマ)
+// ============================================================
+
+/** EFGHCrossDomainResult のσ */
+export function getEFGHCrossSigma(result: EFGHCrossDomainResult): any {
+  return {
+    reiType: 'SigmaResult',
+    domain: 'cross_domain_efgh',
+    subtype: 'bridge',
+    field: {
+      source: result.source,
+      target: result.target,
+      bridge: result.bridge,
+    },
+    flow: {
+      direction: `${result.source.domain}→${result.target.domain}`,
+      momentum: result.metadata.mappingQuality,
+      velocity: 1 - result.metadata.informationLoss,
+    },
+    memory: result.metadata,
+    layer: { depth: 2, structure: 'cross-domain-efgh' },
+    relation: {
+      from: result.source.domain,
+      to: result.target.domain,
+      type: result.bridge,
+      synesthesia: result.metadata.synesthesia,
+    },
+    will: {
+      tendency: 'integrate',
+      strength: result.metadata.mappingQuality,
+    },
+  };
+}
+
+/** UniversalComposition のσ */
+export function getUniversalSigma(comp: UniversalComposition): any {
+  const domainNames = Object.keys(comp.domains).filter(k => comp.domains[k].raw !== null);
+  return {
+    reiType: 'SigmaResult',
+    domain: 'universal',
+    subtype: 'composition',
+    field: {
+      domains: domainNames,
+      commonPatterns: comp.synthesis.commonPatterns,
+      domainCount: comp.synthesis.domainCount,
+    },
+    flow: {
+      direction: 'universal_convergence',
+      momentum: comp.synthesis.harmony,
+      velocity: comp.synthesis.universality,
+    },
+    memory: Object.fromEntries(
+      Object.entries(comp.domains)
+        .filter(([_, v]) => v.raw !== null)
+        .map(([k, v]) => [k, v.metrics])
+    ),
+    layer: {
+      depth: comp.synthesis.domainCount,
+      structure: 'universal',
+    },
+    relation: {
+      tensions: comp.synthesis.tensions,
+      patterns: comp.synthesis.commonPatterns,
+    },
+    will: {
+      tendency: comp.synthesis.emergent ?? 'exploring',
+      strength: comp.synthesis.universality,
+      emergent: comp.synthesis.emergent,
+    },
+    harmony: comp.synthesis.harmony,
+    universality: comp.synthesis.universality,
+    emergent: comp.synthesis.emergent,
+  };
+}
+
+/** ブリッジ結果をEFGHCrossDomainResultでラップ */
+export function wrapEFGHCross(
+  data: any,
+  sourceDomain: string,
+  sourceType: string,
+  targetDomain: string,
+  targetType: string,
+  bridge: string,
+  extra?: Partial<EFGHCrossDomainResult['metadata']>,
+): EFGHCrossDomainResult {
+  return {
+    reiType: 'EFGHCrossDomainResult',
+    source: { domain: sourceDomain, type: sourceType },
+    target: { domain: targetDomain, type: targetType },
+    bridge,
+    data,
+    metadata: {
+      sourceMetrics: {},
+      targetMetrics: {},
+      mappingQuality: 0.8,
+      informationLoss: 0.15,
+      ...extra,
+    },
+  };
+}
diff --git a/src/lang/evaluator.ts b/src/lang/evaluator.ts
index 275efbf..84187ec 100644
--- a/src/lang/evaluator.ts
+++ b/src/lang/evaluator.ts
@@ -282,6 +282,21 @@ import {
   type SyntaxTree, type SemanticFrame, type WordRelation, type TranslationResult,
 } from './domains/linguistics';
 
+// ── Phase 6.5: EFGH ドメイン横断統合 ──
+import {
+  artToMusic, musicToArt,
+  artToMarket, marketToArt,
+  artToText, textToArt,
+  musicToMarket, marketToMusic,
+  musicToText, textToMusic,
+  marketToText, textToMarket,
+  artToSim, musicToSim, marketToSim,
+  marketEthics, linguisticsToHumanities, linguisticsToPipeline,
+  composeAll,
+  getEFGHCrossSigma, getUniversalSigma,
+  type EFGHCrossDomainResult, type UniversalComposition,
+} from './domains/cross-domain-efgh';
+
 // ── 型システム強化 ──
 import {
   inferType, typeCheck, typeDomain, checkPipeCompatibility,
@@ -3428,7 +3443,98 @@ export class Evaluator {
     if (cmdName === "cross_sigma" || cmdName === "横断σ") {
       if (rawInput?.reiType === 'CrossDomainResult') return getCrossDomainSigma(rawInput);
       if (rawInput?.reiType === 'DomainComposition') return getDomainCompositionSigma(rawInput);
-      throw new Error('cross_sigma: CrossDomainResult or DomainCompositionが必要です');
+      if (rawInput?.reiType === 'EFGHCrossDomainResult') return getEFGHCrossSigma(rawInput);
+      if (rawInput?.reiType === 'UniversalComposition') return getUniversalSigma(rawInput);
+      throw new Error('cross_sigma: CrossDomainResult, DomainComposition, EFGHCrossDomainResult, or UniversalCompositionが必要です');
+    }
+
+    // ═══════════════════════════════════════════════════════════
+    // Phase 6.5: EFGH ドメイン横断統合
+    // ═══════════════════════════════════════════════════════════
+
+    // E↔F: 芸術 ↔ 音楽 (共感覚)
+    if (cmdName === "art_to_music" || cmdName === "芸術→音楽") {
+      return artToMusic(rawInput);
+    }
+    if (cmdName === "music_to_art" || cmdName === "音楽→芸術") {
+      return musicToArt(rawInput);
+    }
+
+    // E↔G: 芸術 ↔ 経済学
+    if (cmdName === "art_to_market" || cmdName === "芸術→市場") {
+      return artToMarket(rawInput);
+    }
+    if (cmdName === "market_to_art" || cmdName === "市場→芸術") {
+      return marketToArt(rawInput);
+    }
+
+    // E↔H: 芸術 ↔ 言語学
+    if (cmdName === "art_to_text" || cmdName === "芸術→言語") {
+      return artToText(rawInput);
+    }
+    if (cmdName === "text_to_art" || cmdName === "言語→芸術") {
+      return textToArt(rawInput);
+    }
+
+    // F↔G: 音楽 ↔ 経済学
+    if (cmdName === "music_to_market" || cmdName === "音楽→市場") {
+      return musicToMarket(rawInput);
+    }
+    if (cmdName === "market_to_music" || cmdName === "市場→音楽") {
+      return marketToMusic(rawInput);
+    }
+
+    // F↔H: 音楽 ↔ 言語学
+    if (cmdName === "music_to_text" || cmdName === "音楽→言語") {
+      return musicToText(rawInput);
+    }
+    if (cmdName === "text_to_music" || cmdName === "言語→音楽") {
+      return textToMusic(rawInput);
+    }
+
+    // G↔H: 経済学 ↔ 言語学
+    if (cmdName === "market_to_text" || cmdName === "市場→言語") {
+      return marketToText(rawInput);
+    }
+    if (cmdName === "text_to_market" || cmdName === "言語→市場") {
+      return textToMarket(rawInput);
+    }
+
+    // EFGH → BCD ブリッジ
+    if (cmdName === "art_to_sim" || cmdName === "芸術→シミュ") {
+      return artToSim(rawInput);
+    }
+    if (cmdName === "music_to_sim" || cmdName === "音楽→シミュ") {
+      return musicToSim(rawInput);
+    }
+    if (cmdName === "market_to_sim" || cmdName === "市場→シミュ") {
+      return marketToSim(rawInput);
+    }
+    if (cmdName === "market_ethics" || cmdName === "市場倫理") {
+      return marketEthics(rawInput);
+    }
+    if (cmdName === "linguistics_to_humanities" || cmdName === "言語→人文") {
+      return linguisticsToHumanities(rawInput);
+    }
+    if (cmdName === "linguistics_to_pipeline" || cmdName === "言語→パイプ") {
+      return linguisticsToPipeline(rawInput);
+    }
+
+    // 7ドメイン全体統合
+    if (cmdName === "compose_all" || cmdName === "全領域統合") {
+      if (rawInput && typeof rawInput === 'object' && !Array.isArray(rawInput)) {
+        return composeAll(rawInput as Record<string, any>);
+      }
+      // argsから構築
+      const inputs: Record<string, any> = {};
+      if (rawInput) inputs.B = rawInput;
+      if (args.length >= 1) inputs.C = args[0];
+      if (args.length >= 2) inputs.D = args[1];
+      if (args.length >= 3) inputs.E = args[2];
+      if (args.length >= 4) inputs.F = args[3];
+      if (args.length >= 5) inputs.G = args[4];
+      if (args.length >= 6) inputs.H = args[5];
+      return composeAll(inputs);
     }
 
     // ═══════════════════════════════════════════════════════════
diff --git a/tests/cross-domain-efgh.test.ts b/tests/cross-domain-efgh.test.ts
new file mode 100644
index 0000000..f114dd5
--- /dev/null
+++ b/tests/cross-domain-efgh.test.ts
@@ -0,0 +1,785 @@
+/**
+ * Phase 6.5: EFGH ドメイン横断統合テスト
+ *
+ * E(芸術) × F(音楽) × G(経済学) × H(言語学) の相互連携
+ * + EFGH → BCD ブリッジ
+ * + 7ドメイン全体統合
+ */
+
+import { describe, test, expect, beforeEach } from 'vitest';
+import { rei } from '../src/index';
+import {
+  artToMusic, musicToArt,
+  artToMarket, marketToArt,
+  artToText, textToArt,
+  musicToMarket, marketToMusic,
+  musicToText, textToMusic,
+  marketToText, textToMarket,
+  artToSim, musicToSim, marketToSim,
+  marketEthics, linguisticsToHumanities, linguisticsToPipeline,
+  composeAll,
+  getEFGHCrossSigma, getUniversalSigma,
+  wrapEFGHCross,
+} from '../src/lang/domains/cross-domain-efgh';
+import { colorHarmony, generateFractal, analyzeAesthetics } from '../src/lang/domains/art';
+import { createScale, createChord, createMelody, createRhythm } from '../src/lang/domains/music';
+import { createMarket, marketRun, supplyDemand, createGame } from '../src/lang/domains/economics';
+import { parseSyntax, createSemanticFrame, translate, analyzeWord } from '../src/lang/domains/linguistics';
+import { createNBodySpace } from '../src/lang/domains/natural-science';
+import { createPipelineSpace } from '../src/lang/domains/pipeline-core';
+import { simRun } from '../src/lang/domains/simulation-core';
+import { analyzeText, evaluateEthics } from '../src/lang/domains/humanities';
+
+beforeEach(() => { rei.reset(); });
+
+// ============================================================
+// E↔F: 芸術 ↔ 音楽 (共感覚)
+// ============================================================
+
+describe('E↔F: 芸術 ↔ 音楽 (共感覚)', () => {
+  test('art_to_music: ColorHarmony → ScaleResult', () => {
+    const ch = colorHarmony(0, 'complementary');
+    const scale = artToMusic(ch);
+    expect(scale.reiType).toBe('ScaleResult');
+    expect(scale.root).toBe('C');  // hue=0 → C
+    expect(scale.mode).toBe('major');  // complementary → major
+    expect(scale.notes.length).toBeGreaterThan(0);
+  });
+
+  test('art_to_music: PatternResult → ScaleResult', () => {
+    const pattern = generateFractal(10, 10, 20);
+    const scale = artToMusic(pattern);
+    expect(scale.reiType).toBe('ScaleResult');
+    expect(scale.notes.length).toBeGreaterThan(0);
+  });
+
+  test('art_to_music: AestheticAnalysis → ScaleResult', () => {
+    const aesthetics = analyzeAesthetics(generateFractal(10, 10, 20));
+    const scale = artToMusic(aesthetics);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('art_to_music: 数値 (hue) → ScaleResult', () => {
+    const scale = artToMusic(120);  // hue=120 → E
+    expect(scale.reiType).toBe('ScaleResult');
+    expect(scale.root).toBe('E');
+  });
+
+  test('music_to_art: ScaleResult → ColorHarmony', () => {
+    const scale = createScale('C', 'major');
+    const ch = musicToArt(scale);
+    expect(ch.reiType).toBe('ColorHarmony');
+    expect(ch.base.h).toBe(0);  // C → hue 0
+    expect(ch.scheme).toBe('complementary');  // major → complementary
+  });
+
+  test('music_to_art: ChordResult → ColorHarmony', () => {
+    const chord = createChord('G', 'major');
+    const ch = musicToArt(chord);
+    expect(ch.reiType).toBe('ColorHarmony');
+    expect(ch.base.h).toBe(210);  // G → hue 210
+  });
+
+  test('music_to_art: MelodyResult → ColorHarmony', () => {
+    const scale = createScale('A', 'minor');
+    const melody = createMelody(scale, 8, 'stepwise');
+    const ch = musicToArt(melody);
+    expect(ch.reiType).toBe('ColorHarmony');
+  });
+
+  test('ラウンドトリップ: Color → Scale → Color', () => {
+    const original = colorHarmony(60, 'triadic');
+    const scale = artToMusic(original);
+    const roundtrip = musicToArt(scale);
+    expect(roundtrip.reiType).toBe('ColorHarmony');
+    // ドメインが保存される（完全一致は不要だが型は同じ）
+  });
+
+  test('パイプ経由: art_to_music', () => {
+    const result = rei('0 |> color_harmony("complementary") |> art_to_music');
+    expect(result.reiType).toBe('ScaleResult');
+  });
+
+  test('パイプ経由: music_to_art', () => {
+    const result = rei('"C" |> scale("major") |> music_to_art');
+    expect(result.reiType).toBe('ColorHarmony');
+  });
+});
+
+// ============================================================
+// E↔G: 芸術 ↔ 経済学
+// ============================================================
+
+describe('E↔G: 芸術 ↔ 経済学', () => {
+  test('art_to_market: AestheticAnalysis → MarketState', () => {
+    const aesthetics = analyzeAesthetics(generateFractal(10, 10, 20));
+    const market = artToMarket(aesthetics);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.price).toBeGreaterThan(0);
+    expect(market.agents.length).toBeGreaterThan(0);
+  });
+
+  test('art_to_market: ColorHarmony → MarketState', () => {
+    const ch = colorHarmony(120, 'analogous');
+    const market = artToMarket(ch);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toContain('color_market');
+  });
+
+  test('market_to_art: MarketState → PatternResult', () => {
+    const market = marketRun(createMarket('test', 100, 5), 20);
+    const pattern = marketToArt(market);
+    expect(pattern.reiType).toBe('PatternResult');
+    expect(pattern.data.length).toBeGreaterThan(0);
+    expect(pattern.params.sourceDomain).toBe('economics');
+  });
+
+  test('market_to_art: SupplyDemandResult → PatternResult', () => {
+    const sd = supplyDemand(1, 0, -1, 100);
+    const pattern = marketToArt(sd);
+    expect(pattern.reiType).toBe('PatternResult');
+  });
+
+  test('パイプ経由: art_to_market', () => {
+    const result = rei('10 |> fractal(10, 20) |> aesthetics |> art_to_market');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('パイプ経由: market_to_art', () => {
+    const result = rei('"art" |> market(100, 5) |> market_run(20) |> market_to_art');
+    expect(result.reiType).toBe('PatternResult');
+  });
+});
+
+// ============================================================
+// E↔H: 芸術 ↔ 言語学
+// ============================================================
+
+describe('E↔H: 芸術 ↔ 言語学', () => {
+  test('art_to_text: AestheticAnalysis → SyntaxTree', () => {
+    const aesthetics = analyzeAesthetics(generateFractal(10, 10, 20));
+    const tree = artToText(aesthetics);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence.length).toBeGreaterThan(0);
+  });
+
+  test('art_to_text: ColorHarmony → SyntaxTree', () => {
+    const ch = colorHarmony(60, 'analogous');
+    const tree = artToText(ch);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('色彩調和');
+  });
+
+  test('art_to_text: PatternResult → SyntaxTree', () => {
+    const pattern = generateFractal(10, 10, 20);
+    const tree = artToText(pattern);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('パターン');
+  });
+
+  test('text_to_art: SyntaxTree → ColorHarmony', () => {
+    const tree = parseSyntax('美しい風景を描写する');
+    const ch = textToArt(tree);
+    expect(ch.reiType).toBe('ColorHarmony');
+    expect(ch.colors.length).toBeGreaterThan(0);
+  });
+
+  test('text_to_art: SemanticFrame → ColorHarmony', () => {
+    const frame = createSemanticFrame('描く', { agent: '画家', theme: '風景' });
+    const ch = textToArt(frame);
+    expect(ch.reiType).toBe('ColorHarmony');
+  });
+
+  test('text_to_art: TranslationResult → ColorHarmony', () => {
+    const tr = translate('美しい', 'ja', 'en');
+    const ch = textToArt(tr);
+    expect(ch.reiType).toBe('ColorHarmony');
+  });
+
+  test('パイプ経由: art_to_text', () => {
+    const result = rei('0 |> color_harmony("complementary") |> art_to_text');
+    expect(result.reiType).toBe('SyntaxTree');
+  });
+});
+
+// ============================================================
+// F↔G: 音楽 ↔ 経済学
+// ============================================================
+
+describe('F↔G: 音楽 ↔ 経済学', () => {
+  test('music_to_market: ScaleResult → MarketState', () => {
+    const scale = createScale('C', 'major');
+    const market = musicToMarket(scale);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toContain('scale_market');
+  });
+
+  test('music_to_market: MelodyResult → MarketState', () => {
+    const scale = createScale('A', 'minor');
+    const melody = createMelody(scale, 8, 'stepwise');
+    const market = musicToMarket(melody);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toBe('melody_market');
+  });
+
+  test('music_to_market: RhythmPattern → MarketState', () => {
+    const rhythm = createRhythm(4, 4, 0.5, 120);
+    const market = musicToMarket(rhythm);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toContain('rhythm_market');
+  });
+
+  test('music_to_market: ChordResult → MarketState', () => {
+    const chord = createChord('G', 'major');
+    const market = musicToMarket(chord);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toContain('chord_market');
+  });
+
+  test('market_to_music: MarketState(bull) → major scale or melody', () => {
+    let market = createMarket('test', 100, 5);
+    market = marketRun(market, 10);
+    const result = marketToMusic(market);
+    expect(['ScaleResult', 'MelodyResult']).toContain(result.reiType);
+  });
+
+  test('market_to_music: SupplyDemandResult → ScaleResult', () => {
+    const sd = supplyDemand(1, 0, -1, 100);
+    const scale = marketToMusic(sd);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('market_to_music: GameTheoryResult → ScaleResult', () => {
+    const game = createGame('prisoners_dilemma');
+    const scale = marketToMusic(game);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('パイプ経由: music_to_market', () => {
+    const result = rei('"D" |> scale("minor") |> music_to_market');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('パイプ経由: market_to_music', () => {
+    const result = rei('"m" |> market(100, 5) |> market_run(10) |> market_to_music');
+    expect(['ScaleResult', 'MelodyResult']).toContain(result.reiType);
+  });
+});
+
+// ============================================================
+// F↔H: 音楽 ↔ 言語学
+// ============================================================
+
+describe('F↔H: 音楽 ↔ 言語学', () => {
+  test('music_to_text: ScaleResult → SyntaxTree', () => {
+    const scale = createScale('C', 'major');
+    const tree = musicToText(scale);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('音階');
+  });
+
+  test('music_to_text: MelodyResult → SyntaxTree', () => {
+    const scale = createScale('A', 'minor');
+    const melody = createMelody(scale, 8, 'stepwise');
+    const tree = musicToText(melody);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('旋律');
+  });
+
+  test('music_to_text: ChordResult → SyntaxTree', () => {
+    const chord = createChord('E', 'minor');
+    const tree = musicToText(chord);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('和音');
+  });
+
+  test('music_to_text: RhythmPattern → SyntaxTree', () => {
+    const rhythm = createRhythm(4, 4, 0.5, 120);
+    const tree = musicToText(rhythm);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('リズム');
+  });
+
+  test('text_to_music: SyntaxTree → ScaleResult', () => {
+    const tree = parseSyntax('鳥が歌を歌う');
+    const scale = textToMusic(tree);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('text_to_music: SemanticFrame → ScaleResult', () => {
+    const frame = createSemanticFrame('演奏する', { agent: '演者', theme: '曲' });
+    const scale = textToMusic(frame);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('text_to_music: TranslationResult → ScaleResult', () => {
+    const tr = translate('音楽', 'ja', 'en');
+    const scale = textToMusic(tr);
+    expect(scale.reiType).toBe('ScaleResult');
+  });
+
+  test('パイプ経由: music_to_text', () => {
+    const result = rei('"C" |> scale("major") |> music_to_text');
+    expect(result.reiType).toBe('SyntaxTree');
+  });
+
+  test('パイプ経由: text_to_music', () => {
+    const result = rei('"鳥が歌を歌う" |> parse |> text_to_music');
+    expect(result.reiType).toBe('ScaleResult');
+  });
+});
+
+// ============================================================
+// G↔H: 経済学 ↔ 言語学
+// ============================================================
+
+describe('G↔H: 経済学 ↔ 言語学', () => {
+  test('market_to_text: MarketState → SyntaxTree', () => {
+    const market = createMarket('stocks', 150, 8);
+    const tree = marketToText(market);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('市場');
+  });
+
+  test('market_to_text: SupplyDemandResult → SyntaxTree', () => {
+    const sd = supplyDemand(1, 0, -1, 100);
+    const tree = marketToText(sd);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('均衡');
+  });
+
+  test('market_to_text: GameTheoryResult → SyntaxTree', () => {
+    const game = createGame('prisoners_dilemma');
+    const tree = marketToText(game);
+    expect(tree.reiType).toBe('SyntaxTree');
+    expect(tree.sentence).toContain('ゲーム');
+  });
+
+  test('text_to_market: SyntaxTree → MarketState', () => {
+    const tree = parseSyntax('株式市場が上昇する');
+    const market = textToMarket(tree);
+    expect(market.reiType).toBe('MarketState');
+    expect(market.name).toContain('syntax_market');
+  });
+
+  test('text_to_market: SemanticFrame → MarketState', () => {
+    const frame = createSemanticFrame('取引する', { agent: '投資家', theme: '株式' });
+    const market = textToMarket(frame);
+    expect(market.reiType).toBe('MarketState');
+  });
+
+  test('text_to_market: TranslationResult → MarketState', () => {
+    const tr = translate('市場', 'ja', 'en');
+    const market = textToMarket(tr);
+    expect(market.reiType).toBe('MarketState');
+  });
+
+  test('パイプ経由: market_to_text', () => {
+    const result = rei('"stocks" |> market(100, 5) |> market_to_text');
+    expect(result.reiType).toBe('SyntaxTree');
+  });
+
+  test('パイプ経由: text_to_market', () => {
+    const result = rei('"市場が上昇する" |> parse |> text_to_market');
+    expect(result.reiType).toBe('MarketState');
+  });
+});
+
+// ============================================================
+// EFGH → BCD ブリッジ
+// ============================================================
+
+describe('EFGH → BCD ブリッジ', () => {
+  // E → B
+  test('art_to_sim: PatternResult → SimulationSpace', () => {
+    const pattern = generateFractal(15, 15, 30);
+    const sim = artToSim(pattern);
+    expect(sim.reiType).toBe('SimulationSpace');
+    expect(sim.particles.length).toBeGreaterThanOrEqual(3);
+  });
+
+  test('art_to_sim: ColorHarmony → SimulationSpace', () => {
+    const ch = colorHarmony(0, 'triadic');
+    const sim = artToSim(ch);
+    expect(sim.reiType).toBe('SimulationSpace');
+    expect(sim.particles.length).toBeGreaterThanOrEqual(3);
+  });
+
+  // F → B
+  test('music_to_sim: ScaleResult → SimulationSpace', () => {
+    const scale = createScale('C', 'major');
+    const sim = musicToSim(scale);
+    expect(sim.reiType).toBe('SimulationSpace');
+    expect(sim.particles.length).toBe(scale.notes.length);
+    expect(sim.particles[0].properties).toHaveProperty('frequency');
+  });
+
+  test('music_to_sim: MelodyResult → SimulationSpace', () => {
+    const scale = createScale('A', 'minor');
+    const melody = createMelody(scale, 8, 'stepwise');
+    const sim = musicToSim(melody);
+    expect(sim.reiType).toBe('SimulationSpace');
+  });
+
+  test('music_to_sim: RhythmPattern → SimulationSpace', () => {
+    const rhythm = createRhythm(4, 4, 0.5, 120);
+    const sim = musicToSim(rhythm);
+    expect(sim.reiType).toBe('SimulationSpace');
+    expect(sim.particles.length).toBeGreaterThanOrEqual(3);
+  });
+
+  // G → B
+  test('market_to_sim: MarketState → SimulationSpace', () => {
+    const market = createMarket('test', 100, 8);
+    const sim = marketToSim(market);
+    expect(sim.reiType).toBe('SimulationSpace');
+    expect(sim.particles.length).toBe(market.agents.length);
+  });
+
+  // G → D
+  test('market_ethics: MarketState → EthicsResult', () => {
+    const market = createMarket('test', 100, 5);
+    const ethics = marketEthics(market);
+    expect(ethics.reiType).toBe('EthicsResult');
+    expect(ethics.perspectives.length).toBeGreaterThan(0);
+  });
+
+  test('market_ethics: GameTheoryResult → EthicsResult', () => {
+    const game = createGame('prisoners_dilemma');
+    const ethics = marketEthics(game);
+    expect(ethics.reiType).toBe('EthicsResult');
+  });
+
+  // H → D
+  test('linguistics_to_humanities: SyntaxTree → TextAnalysis', () => {
+    const tree = parseSyntax('自然言語処理は重要な技術である');
+    const text = linguisticsToHumanities(tree);
+    expect(text.reiType).toBe('TextAnalysis');
+    expect(text.original.length).toBeGreaterThan(0);
+  });
+
+  test('linguistics_to_humanities: TranslationResult → TextAnalysis', () => {
+    const tr = translate('科学', 'ja', 'en');
+    const text = linguisticsToHumanities(tr);
+    expect(text.reiType).toBe('TextAnalysis');
+  });
+
+  test('linguistics_to_humanities: SemanticFrame → TextAnalysis', () => {
+    const frame = createSemanticFrame('研究する', { agent: '科学者', theme: '物理' });
+    const text = linguisticsToHumanities(frame);
+    expect(text.reiType).toBe('TextAnalysis');
+  });
+
+  test('linguistics_to_humanities: WordRelation → TextAnalysis', () => {
+    const word = analyzeWord('知識');
+    const text = linguisticsToHumanities(word);
+    expect(text.reiType).toBe('TextAnalysis');
+  });
+
+  // H → C
+  test('linguistics_to_pipeline: TranslationResult → PipelineSpace', () => {
+    const tr = translate('猫が魚を食べる', 'ja', 'en');
+    const pipeline = linguisticsToPipeline(tr);
+    expect(pipeline.reiType).toBe('PipelineSpace');
+    expect(Array.isArray(pipeline.data)).toBe(true);
+    expect(pipeline.metadata.sourceDomain).toBe('linguistics');
+  });
+
+  test('linguistics_to_pipeline: SyntaxTree → PipelineSpace', () => {
+    const tree = parseSyntax('猫が走る');
+    const pipeline = linguisticsToPipeline(tree);
+    expect(pipeline.reiType).toBe('PipelineSpace');
+    expect(Array.isArray(pipeline.data)).toBe(true);
+  });
+
+  test('linguistics_to_pipeline: WordRelation → PipelineSpace', () => {
+    const word = analyzeWord('言語');
+    const pipeline = linguisticsToPipeline(word);
+    expect(pipeline.reiType).toBe('PipelineSpace');
+  });
+
+  // パイプ経由
+  test('パイプ経由: art_to_sim', () => {
+    const result = rei('10 |> fractal(10, 20) |> art_to_sim');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('パイプ経由: music_to_sim', () => {
+    const result = rei('"C" |> scale("major") |> music_to_sim');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('パイプ経由: market_to_sim', () => {
+    const result = rei('"test" |> market(100, 8) |> market_to_sim');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('パイプ経由: market_ethics', () => {
+    const result = rei('"test" |> market(100, 5) |> market_ethics');
+    expect(result.reiType).toBe('EthicsResult');
+  });
+
+  test('パイプ経由: linguistics_to_humanities', () => {
+    const result = rei('"科学は進歩する" |> parse |> linguistics_to_humanities');
+    expect(result.reiType).toBe('TextAnalysis');
+  });
+
+  test('パイプ経由: linguistics_to_pipeline', () => {
+    const result = rei('"猫" |> translate("ja", "en") |> linguistics_to_pipeline');
+    expect(result.reiType).toBe('PipelineSpace');
+  });
+});
+
+// ============================================================
+// 多段パイプ (マルチドメイン横断)
+// ============================================================
+
+describe('マルチドメイン横断パイプ', () => {
+  test('E→F→G: 芸術→音楽→経済', () => {
+    const result = rei('60 |> color_harmony("triadic") |> art_to_music |> music_to_market');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('H→F→E: 言語→音楽→芸術', () => {
+    const result = rei('"鳥が歌う" |> parse |> text_to_music |> music_to_art');
+    expect(result.reiType).toBe('ColorHarmony');
+  });
+
+  test('G→F→E→H: 経済→音楽→芸術→言語', () => {
+    const result = rei('"m" |> market(100, 5) |> market_run(10) |> market_to_music |> music_to_art |> art_to_text');
+    expect(result.reiType).toBe('SyntaxTree');
+  });
+
+  test('E→B: 芸術→シミュ→パイプライン (BCD横断)', () => {
+    const result = rei('10 |> fractal(10, 20) |> art_to_sim |> sim_to_pipeline');
+    expect(result.reiType).toBe('PipelineSpace');
+  });
+
+  test('F→B→D: 音楽→シミュ→因果ネットワーク', () => {
+    const scale = createScale('C', 'major');
+    const sim = musicToSim(scale);
+    const simulated = simRun(sim, 5);
+    expect(simulated.reiType).toBe('SimulationSpace');
+    expect(simulated.history.length).toBeGreaterThan(0);
+  });
+
+  test('G→D→C: 経済→倫理→テキスト', () => {
+    const market = createMarket('ethics_test', 100, 5);
+    const ethics = marketEthics(market);
+    expect(ethics.reiType).toBe('EthicsResult');
+    expect(ethics.perspectives.length).toBeGreaterThan(0);
+  });
+});
+
+// ============================================================
+// 日本語エイリアス
+// ============================================================
+
+describe('日本語エイリアス', () => {
+  test('芸術→音楽', () => {
+    const result = rei('0 |> color_harmony("complementary") |> 芸術→音楽');
+    expect(result.reiType).toBe('ScaleResult');
+  });
+
+  test('音楽→芸術', () => {
+    const result = rei('"C" |> scale("major") |> 音楽→芸術');
+    expect(result.reiType).toBe('ColorHarmony');
+  });
+
+  test('芸術→市場', () => {
+    const result = rei('10 |> fractal(10, 20) |> aesthetics |> 芸術→市場');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('市場→芸術', () => {
+    const result = rei('"m" |> market(100, 5) |> market_run(20) |> 市場→芸術');
+    expect(result.reiType).toBe('PatternResult');
+  });
+
+  test('音楽→市場', () => {
+    const result = rei('"D" |> scale("minor") |> 音楽→市場');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('市場→音楽', () => {
+    const result = rei('"m" |> market(100, 5) |> market_run(10) |> 市場→音楽');
+    expect(['ScaleResult', 'MelodyResult']).toContain(result.reiType);
+  });
+
+  test('市場→言語', () => {
+    const result = rei('"stocks" |> market(100, 5) |> 市場→言語');
+    expect(result.reiType).toBe('SyntaxTree');
+  });
+
+  test('言語→市場', () => {
+    const result = rei('"市場が上昇する" |> parse |> 言語→市場');
+    expect(result.reiType).toBe('MarketState');
+  });
+
+  test('芸術→シミュ', () => {
+    const result = rei('10 |> fractal(10, 20) |> 芸術→シミュ');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('音楽→シミュ', () => {
+    const result = rei('"C" |> scale("major") |> 音楽→シミュ');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('市場→シミュ', () => {
+    const result = rei('"m" |> market(100, 8) |> 市場→シミュ');
+    expect(result.reiType).toBe('SimulationSpace');
+  });
+
+  test('市場倫理', () => {
+    const result = rei('"m" |> market(100, 5) |> 市場倫理');
+    expect(result.reiType).toBe('EthicsResult');
+  });
+
+  test('言語→人文', () => {
+    const result = rei('"科学は進歩する" |> parse |> 言語→人文');
+    expect(result.reiType).toBe('TextAnalysis');
+  });
+
+  test('言語→パイプ', () => {
+    const result = rei('"猫" |> translate("ja", "en") |> 言語→パイプ');
+    expect(result.reiType).toBe('PipelineSpace');
+  });
+});
+
+// ============================================================
+// 7ドメイン全体統合
+// ============================================================
+
+describe('7ドメイン全体統合 (compose_all)', () => {
+  test('全ドメイン統合: 基本', () => {
+    const sim = simRun(createNBodySpace(3, 'gravity', {}), 5);
+    const pipeline = createPipelineSpace([1, 2, 3]);
+    const text = analyzeText('テスト文');
+    const pattern = generateFractal(10, 10, 20);
+    const scale = createScale('C', 'major');
+    const market = createMarket('test', 100, 5);
+    const syntax = parseSyntax('テストの文を解析する');
+
+    const composition = composeAll({
+      natural_science: sim,
+      info_engineering: pipeline,
+      humanities: text,
+      art: pattern,
+      music: scale,
+      economics: market,
+      linguistics: syntax,
+    });
+
+    expect(composition.reiType).toBe('UniversalComposition');
+    expect(composition.synthesis.domainCount).toBe(7);
+    expect(composition.synthesis.harmony).toBeGreaterThanOrEqual(0);
+    expect(composition.synthesis.harmony).toBeLessThanOrEqual(1);
+    expect(composition.synthesis.universality).toBeGreaterThanOrEqual(0);
+  });
+
+  test('部分統合: 4ドメインのみ', () => {
+    const composition = composeAll({
+      art: generateFractal(10, 10, 20),
+      music: createScale('C', 'major'),
+      economics: createMarket('test', 100, 5),
+      linguistics: parseSyntax('テスト'),
+    });
+
+    expect(composition.reiType).toBe('UniversalComposition');
+    expect(composition.synthesis.domainCount).toBe(4);
+    // E/F/G/Hのみ提供してもB/C/Dはnullで処理
+    expect(composition.domains.natural_science.raw).toBeNull();
+  });
+
+  test('7ドメイン統合: 共通パターン検出', () => {
+    const composition = composeAll({
+      natural_science: simRun(createNBodySpace(5, 'gravity', {}), 10),
+      info_engineering: createPipelineSpace([1, 2, 3, 4, 5]),
+      humanities: analyzeText('深い哲学的な考察を行う文章である'),
+      art: colorHarmony(0, 'triadic'),
+      music: createScale('A', 'minor'),
+      economics: createMarket('complex', 200, 15),
+      linguistics: parseSyntax('複雑な構造を持つ文を解析する'),
+    });
+
+    expect(composition.synthesis.domainCount).toBe(7);
+    expect(Array.isArray(composition.synthesis.commonPatterns)).toBe(true);
+    expect(Array.isArray(composition.synthesis.tensions)).toBe(true);
+  });
+
+  test('7ドメイン統合σ', () => {
+    const composition = composeAll({
+      art: generateFractal(10, 10, 20),
+      music: createScale('C', 'major'),
+      economics: createMarket('test', 100, 5),
+      linguistics: parseSyntax('テスト'),
+    });
+
+    const sigma = getUniversalSigma(composition);
+    expect(sigma.reiType).toBe('SigmaResult');
+    expect(sigma.domain).toBe('universal');
+    expect(sigma.field.domainCount).toBe(4);
+    expect(sigma).toHaveProperty('universality');
+    expect(sigma).toHaveProperty('harmony');
+  });
+
+  test('BラベルでのアクセスもOK', () => {
+    const composition = composeAll({
+      B: simRun(createNBodySpace(3, 'gravity', {}), 5),
+      E: generateFractal(10, 10, 20),
+      F: createScale('C', 'major'),
+    });
+
+    expect(composition.reiType).toBe('UniversalComposition');
+    expect(composition.synthesis.domainCount).toBe(3);
+  });
+});
+
+// ============================================================
+// σ (シグマ) テスト
+// ============================================================
+
+describe('EFGH Cross-Domain σ', () => {
+  test('wrapEFGHCross: ブリッジ結果のラップ', () => {
+    const scale = createScale('C', 'major');
+    const wrapped = wrapEFGHCross(
+      scale, 'art', 'ColorHarmony', 'music', 'ScaleResult', 'art_to_music',
+      { synesthesia: 0.8 },
+    );
+    expect(wrapped.reiType).toBe('EFGHCrossDomainResult');
+    expect(wrapped.bridge).toBe('art_to_music');
+    expect(wrapped.metadata.synesthesia).toBe(0.8);
+  });
+
+  test('getEFGHCrossSigma: σ取得', () => {
+    const wrapped = wrapEFGHCross(
+      createScale('C', 'major'),
+      'art', 'ColorHarmony', 'music', 'ScaleResult', 'art_to_music',
+    );
+    const sigma = getEFGHCrossSigma(wrapped);
+    expect(sigma.reiType).toBe('SigmaResult');
+    expect(sigma.domain).toBe('cross_domain_efgh');
+    expect(sigma.flow.direction).toBe('art→music');
+  });
+
+  test('横断σ: EFGHCrossDomainResult対応', () => {
+    const wrapped = wrapEFGHCross(
+      createScale('C', 'major'),
+      'art', 'ColorHarmony', 'music', 'ScaleResult', 'art_to_music',
+    );
+    const sigma = getEFGHCrossSigma(wrapped);
+    expect(sigma.reiType).toBe('SigmaResult');
+    expect(sigma.domain).toBe('cross_domain_efgh');
+  });
+
+  test('横断σ: UniversalComposition対応', () => {
+    const composition = composeAll({
+      art: generateFractal(10, 10, 20),
+      music: createScale('C', 'major'),
+    });
+    const sigma = getUniversalSigma(composition);
+    expect(sigma.reiType).toBe('SigmaResult');
+    expect(sigma.domain).toBe('universal');
+  });
+});
-- 
2.43.0

