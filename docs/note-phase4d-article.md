# Rei v0.5.3 — "Values That Know Themselves"（Phase 4d: 安定化＋外部証明）

## はじめに

Rei (0₀式 / れいしき) の v0.5.3 をリリースしました。

今回は新機能の追加ではありません。**「外部の人がReiの価値を自分の手で確認できる状態」を作る**ための安定化リリースです。

Phase 4a〜4cで6属性システム（場・流れ・記憶・層・関係・意志）がすべて深化完了し、891テスト全パスまで到達しました。ここで一度立ち止まり、「これで何ができるか」を世界に見せる準備をしました。

```bash
npm install rei-lang
```

---

## なぜ安定化なのか

正直に書きます。

Reiには機能が十分にあります。6属性、依存追跡、影響度スコアリング、意志の自律進化、パズル・ゲーム統一、圧縮理論。内部基盤としては一通り揃っています。

しかし、外から見ると**「何ができるのかわからない言語」**でした。

READMEは機能リストの羅列。ベンチマークは数値だけで再現手順なし。チュートリアルは存在せず、初めてReiに触る人が途方に暮れる状態。

Phase 4dでは、この問題を正面から解決しました。

---

## 新しいREADME — "Values That Know Themselves"

Reiの本質を一言で表すなら：

> **「値が自分自身を知っている言語」**

通常の言語では、値は数値や文字列でしかありません。空間構造、来歴、接続関係、意図——これらはすべてプログラマが手動で構築するものです。

Reiでは、それらが値の**存在論的属性**として組み込まれています。

```rei
let mut x = 𝕄{5; 1, 2, 3}
x |> sigma
// → { field:    { center: 5, neighbors: [1,2,3], dim: 3 },
//     flow:     { velocity: 0, phase: "rest" },
//     memory:   { entries: [...] },
//     layer:    { depth: 1, structure: "flat" },
//     relation: { refs: [], isolated: true },
//     will:     { tendency: "rest", strength: 0 } }
```

2行で6属性のメタデータが取れる。TypeScriptで同じことをするには40行以上のクラス定義が必要です。しかも手動では「追跡し忘れ」が起きますが、Reiでは忘却が構造的に不可能です。

---

## 実行可能なベンチマークスイート

「74%コード削減」と謳ってきましたが、今回初めて**誰でも自分の手で検証できる**形になりました。

```bash
npx vitest run benchmarks/
```

7つのベンチマーク、各々にRei実装とTypeScript等価実装を並べています。

| # | タスク | Rei | TypeScript | 比率 |
|---|--------|-----|-----------|------|
| 1 | 画像カーネル計算 | 3行 | 10+行 | 3.3× |
| 2 | 多次元集約(4モード) | 5行 | 15+行 | 3× |
| 3 | 6属性メタデータ | 2行 | 40+行 | **20×** |
| 4 | 依存グラフ追跡 | 6行 | 30+行 | 5× |
| 5 | 影響度スコアリング | 5行 | 25+行 | 5× |
| 6 | 構造的エンタングルメント | 4行 | 20+行 | 5× |
| 7 | 意志の自律進化 | 3行 | 30+行 | 10× |

最も劇的なのはベンチマーク3（6属性メタデータ）の**20倍**です。

しかし、本当に重要なのは行数ではありません。TypeScriptのベンチマークで書いているすべてのコードは、**プログラマが忘れずに書く必要がある**コードです。Reiでは、メタデータは値に自動的に付随します。

---

## 15分チュートリアル

初めてReiに触る人のための `docs/TUTORIAL.md` を作成しました。

**Part 1 (2分)**: インストール → REPL起動
**Part 2 (3分)**: 𝕄（多次元数）の体験
**Part 3 (5分)**: σ（6属性）の衝撃
**Part 4 (3分)**: relation — 依存追跡
**Part 5 (2分)**: will — 意志の進化

15分後、読者は「Reiが従来の言語と何が違うか」を体感できます。

---

## v1.0への道

`docs/ROADMAP-v1.md` を公開しました。

- **v0.5.x** (現在): 安定化
- **v0.6.0**: API凍結候補
- **v0.7.0**: ドキュメント完備
- **v0.8.0**: コミュニティ準備
- **v1.0.0**: 安定版リリース

v1.0の基準は明確にしました：

> 初めてReiのGitHubを訪れた開発者が、READMEを読み、15分以内にReiを動かし、ベンチマークを自分で確認し、「この言語には独自の価値がある」と判断できる状態。

---

## API安定性の分類

今回、すべての公開APIをStable / Provisional / Experimentalの3段階に分類しました。

- **Stable**: `rei()`, `rei.reset()`, `Lexer`, `Parser`, `Evaluator` — v1.0まで変更しません
- **Provisional**: sigma-deep型, relation/willコマンド — 微調整の可能性あり
- **Experimental**: AgentSpace, RCT圧縮 — 大きな変更の可能性あり

詳細は `docs/API-STABILITY.md` をご覧ください。

---

## テスト数の推移

```
v0.2.1:  91テスト
v0.3.0: 482テスト
v0.4.0: 535テスト
v0.5.0: 721テスト
v0.5.1: 762テスト
v0.5.2: 799テスト → 877テスト (sigma-deep統合)
v0.5.3: 891テスト (+ ベンチマーク14)
```

v1.0の目標は1000テスト以上です。

---

## まとめ

Phase 4dは「何を作ったか」ではなく「どう伝えるか」のフェーズでした。

技術的に優れたものが自動的に伝わることはありません。READMEを書き直し、ベンチマークを追試可能にし、チュートリアルで入口を作り、ロードマップで信頼性を示す。地味な作業ですが、Reiが「一人の言語」から「使ってもらえる言語」に変わるための必須ステップです。

---

**リポジトリ**: https://github.com/fc0web/rei-lang
**npm**: https://www.npmjs.com/package/rei-lang
**デモ**: https://fc0web.github.io/rei-lang/rei-sigma-demo.html

```bash
npm install rei-lang
npx rei
```

© Nobuki Fujimoto — Apache 2.0 + Peace Use Clause ☮️
