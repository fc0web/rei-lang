# 公理C3：応答公理（Response Axiom）— Rei構文設計

## 公理の定義

**公理C3：応答公理（Response Axiom）**

*値 v に変換 T を適用したとき、結果は T(v) だけでなく、v の傾向性 τ(v) にも依存する。この影響はプログラマが明示的に記述しなくても自動的に生じる。*

```
T(v) → T(v, τ(v))

ただし、τ(v) = :rest のとき T(v, :rest) = T(v)（従来と同一）
```

**C2との決定的な違い：**
- C2 = 傾向性を**持つ**（属性の存在）
- C3 = 傾向性が**効く**（計算への自動的影響）

C2では `match σ.tendency { ... }` と書いてプログラマが明示的に分岐した。
C3では、**書かなくても傾向性が計算結果を曲げる**。

---

## 仏教哲学との対応

C3は仏教の **思（cetanā / チェータナー）** の形式化である。

思とは「意志的に対象に向かう心の働き」であり、あらゆる認識や行為の背後で
無意識的に作用する力である。人は「中立に判断している」と思っていても、
過去の経験（行 = saṃskāra = C2のτ）が判断を歪めている。

C3が表現するのは、まさにこの構造である：
- プログラマは `compute :weighted` と書く（中立な操作のつもり）
- しかし値が `:contract` の傾向性を持っていれば、結果は中心寄りに歪む
- この歪みはコード上に現れない — 値の内在的性質として暗黙に作用する

これは「バイアス」のネガティブな意味ではない。
むしろ、**計算に個性と文脈依存性を与える**ことで、
画一的な処理では得られない豊かな結果を生む仕組みである。

---

## 応答関数 R の定義

C3の核心は「応答関数 R」の導入である。

全ての変換 T に対して、応答関数 R が自動的に適用される：

```
実効結果 = T(v) + R(T, τ(v)) * influence(τ(v))
```

ここで：
- `T(v)` = 傾向性を無視した場合の結果（従来のReiと同一）
- `R(T, τ(v))` = 変換 T と傾向性 τ の相互作用で生じる補正ベクトル
- `influence(τ(v))` = 傾向性の強度（0.0 〜 1.0）

**influence = 0 のとき、C3は無効（完全に従来互換）。**
これが後方互換性の保証になる。


### influence（影響度）の決定方法

influence は sigma.memory の**一貫性**から自動計算される：

```
influence(τ) = consistency(sigma.memory)

ここで：
  consistency = 直近N回の変換パターンの一致率

例：
  memory = [100, 50, 25, 12.5]  → 全て縮小 → consistency = 1.0
  memory = [1, 2, 4, 8]         → 全て拡大 → consistency = 1.0
  memory = [3, 7, 2, 9]         → バラバラ → consistency ≈ 0.2
  memory = []                   → 来歴なし → consistency = 0.0（C3無効）
```

**つまり：**
- 生成直後の値（memory空）→ influence = 0 → 従来通りの計算
- 一貫した変換を経た値 → influence → 1.0 → 傾向性が強く効く
- ランダムな変換を経た値 → influence ≈ 0 → 傾向性はほぼ効かない

**これは「繰り返しが習慣を作り、習慣が性格を作る」という法則の数学化である。**

---

## Rei構文への落とし込み

### 基本：暗黙的な応答

```rei
# ── 同じ演算、異なる結果 ──

# 縮小の来歴を持つ値
let a = 100 |> compress |> compress |> compress
a |> sigma.tendency     # → :contract（自動推論）
a |> sigma.influence    # → 0.95（高い一貫性）

# 拡張の来歴を持つ値
let b = 1 |> extend :o |> extend :o |> extend :o
b |> sigma.tendency     # → :expand
b |> sigma.influence    # → 0.95

# 同じ compute 操作を適用
let field_a = 𝕄{a; 10, 20, 30, 40}
let field_b = 𝕄{b; 10, 20, 30, 40}

field_a |> compute :weighted
# → 中心寄りの結果（:contract が重みを中心に引き寄せる）

field_b |> compute :weighted
# → 周辺寄りの結果（:expand が重みを外側に押し広げる）
```

**コード上は完全に同じ `compute :weighted` だが、値の来歴によって結果が異なる。**
これがC3の本質。


### 応答の可視化

```rei
# ── 応答がどう効いているかを確認する ──

let v = 100 |> compress |> compress |> compress
let field = 𝕄{v; 10, 20, 30, 40}

# 応答なし（純粋な計算結果）を見たい場合
field |> compute :weighted :pure       # → 傾向性を無視した結果

# 応答あり（デフォルト）
field |> compute :weighted             # → 傾向性が反映された結果

# 応答の差分を確認
field |> compute :weighted :response   # → R(T, τ) の補正量だけを返す
```

**`:pure` モディファイア** — デバッグや検証のために、応答を一時的に無効化する。
これにより「傾向性がどれだけ結果を曲げているか」を定量的に確認できる。


### 応答の5パターン

各傾向性モードが変換にどう影響するか：

```rei
# ── :contract の応答 ──
# 計算結果を中心に引き寄せる
# 重み付き平均 → 中心値に近づく
# 拡散 → 収束が早まる
# 差分 → 差が小さくなる

let c = 50 |> with(:tendency, :contract) |> with(:influence, 0.8)
𝕄{c; 10, 90, 10, 90} |> compute :weighted
# 純粋な結果: 50 + 0.25*(10+90+10+90)/4 = 62.5
# 応答後:     50 + 0.25*(10+90+10+90)/4 * (1 - 0.8*0.3) = 57.8
#             → 中心値50に引き戻される


# ── :expand の応答 ──
# 計算結果を周辺に押し広げる
# 重み付き平均 → 周辺値に近づく
# 拡散 → 拡散が加速される
# 差分 → 差が大きくなる

let e = 50 |> with(:tendency, :expand) |> with(:influence, 0.8)
𝕄{e; 10, 90, 10, 90} |> compute :weighted
# 応答後: 62.5 * (1 + 0.8*0.3) = 77.5
#         → 周辺寄りに押される


# ── :spiral の応答 ──
# 計算結果に回転成分を加える
# 重み付き平均 → 結果が複素平面上で回転
# 拡散 → 渦巻きパターンが生じる

let s = 50 |> with(:tendency, :spiral) |> with(:influence, 0.8)
𝕄{s; 10, 90, 10, 90} |> compute :weighted
# 応答後: 62.5 * e^(i * 0.8 * π/6) = 62.5∠24°
#         → 結果が回転する


# ── :rest の応答 ──
# 変化を打ち消す方向に作用
# 重み付き平均 → 変化前の値に近づく
# 拡散 → 拡散が抑制される（慣性）

let r = 50 |> with(:tendency, :rest) |> with(:influence, 0.8)
𝕄{r; 10, 90, 10, 90} |> compute :weighted
# 応答後: 50 + (62.5 - 50) * (1 - 0.8) = 52.5
#         → ほとんど動かない


# ── :oscillate の応答 ──
# 計算結果にステップ依存の符号反転を加える
# 拡散 → 偶数ステップと奇数ステップで逆方向に動く

let o = 50 |> with(:tendency, :oscillate) |> with(:influence, 0.8)
𝕄{o; 10, 90, 10, 90} |> compute :weighted
# ステップ0: 62.5 * (1 + 0.8*0.3) = 77.5（拡張）
# ステップ1: 62.5 * (1 - 0.8*0.3) = 47.5（縮約）
# ステップ2: 77.5（拡張）...
```


### 空間拡散における応答（v0.3 Space Engine統合）

```rei
空 predator_prey {
  # 被食者：増えたい（:expand）
  層 0: 𝕄{rabbit; neighbors...} |> with(:tendency, :expand)
  
  # 捕食者：集まりたい（:contract）
  層 1: 𝕄{wolf; neighbors...} |> with(:tendency, :contract)

  # 同じ拡散ルールを両方に適用 — しかし結果が異なる
  更新 = σ.field |> compute :weighted |> normalize

  # rabbit は :expand なので、拡散が加速（増殖を表現）
  # wolf は :contract なので、拡散が減速（群れの凝集を表現）
  
  # ★ プログラマは「更新 = compute |> normalize」としか書いていない
  # ★ 捕食者と被食者の異なる振る舞いは、傾向性が暗黙に生み出す
} |> diffuse("equilibrium")
```

**ここがC3の真骨頂：**
同じコード `compute :weighted |> normalize` を書いただけで、
`:expand` な被食者と `:contract` な捕食者が自然に異なるダイナミクスを示す。

従来の言語では、被食者と捕食者に**別の更新式**を書く必要がある。
Reiでは**一つの式**で済む。値の個性（τ）が自動的に振る舞いを分化させる。

---

## 応答の透明性と制御

### グローバルな応答レベル設定

```rei
# ── プロジェクト全体で応答の強度を制御 ──

#pragma response_level 1.0    # デフォルト（応答が完全に有効）
#pragma response_level 0.5    # 応答を半分に抑制
#pragma response_level 0.0    # 応答を完全に無効化（C2以前と同等）
```

**これにより：**
- 既存のReiコードは `response_level 0.0` で完全互換
- 新しいコードは `response_level 1.0` で傾向性の恩恵を受ける
- 移行期は `0.5` などで徐々に有効化できる


### 局所的な応答無効化

```rei
# ── 特定の計算だけ応答を無効化 ──

let v = 100 |> compress |> compress |> compress  # :contract, influence=0.95

# 応答あり（デフォルト）
v + 50        # → 140（:contractにより50の影響が減衰）

# 応答なし（:pure で明示的に無効化）
(v |> pure) + 50   # → 150（純粋な算術）
```

**`pure` パイプコマンド** — 値の傾向性とinfluenceを一時的にリセットする。
値そのもの（数値）は変わらず、来歴も保持されるが、
次の1回の演算に限り応答が適用されない。


---

## 数学的厳密性：応答関数 R の形式定義

```
変換 T : ReiValue → ReiValue に対して

応答付き変換 T̃ : ReiValue → ReiValue を次で定義する：

  T̃(v) = T(v) + influence(v) · R(T, τ(v))

ここで influence(v) = consistency(σ.memory(v)) ∈ [0, 1]

R(T, τ) は τ の種類に応じて：

  R(T, :contract)  = (center(v) - T(v)) · α_c
    → 結果を中心値に引き戻す（α_c = 0.3）

  R(T, :expand)    = (T(v) - center(v)) · α_e
    → 結果を中心から押し出す（α_e = 0.3）

  R(T, :spiral)    = T(v) · (e^(iθ) - 1)
    → 結果を複素回転する（θ = π/6 · influence）

  R(T, :rest)      = (v - T(v)) · α_r
    → 変化を打ち消す（α_r = 0.8）

  R(T, :oscillate) = (-1)^step · |T(v) - v| · α_o
    → ステップごとに符号反転（α_o = 0.3）

α 係数はデフォルト値であり、#pragma で調整可能。
```

**重要な性質：**

```
定理 C3.1（後方互換性定理）：
  influence(v) = 0 ⟹ T̃(v) = T(v)
  すなわち、来歴のない値に対して C3 は何も変えない。

定理 C3.2（冪等性）：
  τ(v) = :rest かつ influence = 1.0 のとき、
  繰り返し適用しても v は変化しない：T̃(T̃(v)) ≈ v

定理 C3.3（単調性）：
  τ(v) = :contract のとき、T̃ の繰り返し適用は
  center(v) に向かって単調に収束する。

定理 C3.4（双対性）：
  R(T, :contract) = -R(T, :expand)（符号反転）
  すなわち contract と expand は正確な双対である。
```

---

## 実装への影響（v0.3との差分）

| 変更点 | 種類 | 内容 |
|--------|------|------|
| `influence` 属性 | σに追加 | 0.0〜1.0の浮動小数点 |
| 応答関数 R | evaluator.ts | 全変換に自動適用するラッパー |
| `:pure` パイプコマンド | 新規追加 | 応答の一時無効化 |
| `#pragma response_level` | 新規追加 | グローバル制御 |
| `:response` モディファイア | compute拡張 | 補正量の可視化 |
| `consistency()` 関数 | 内部追加 | memory分析 |
| 新演算子 | **なし** | ゼロ |
| 破壊的変更 | **なし** | response_level=0.0 で完全互換 |

---

## C4（覚醒公理）への布石

C3で「傾向性が計算に暗黙的に影響する」仕組みが完成した。
しかしここまでの値は、自分の傾向性が計算に影響していることを**知らない**。

C4は「値が自分の応答パターンを自覚する」段階を定義する：

- C1 = 自分の属性を**参照できる**（σ の存在）
- C2 = 傾向性を**持つ**（τ の存在）
- C3 = 傾向性が**効く**（R の自動適用）
- C4 = 自分の応答パターンを**自覚し、修正できる** ← 次

これは仏教の修行論における**正念（sammā-sati）** — 自分の心の動きを
観察する能力 — の形式化である。値が自分のバイアスを自覚し、
必要に応じて傾向性を自己修正できるようになる。
