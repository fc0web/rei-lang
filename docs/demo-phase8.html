<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rei 0₀式 — 存在のためのことば</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;500;700&family=Cormorant+Garamond:ital,wght@0,300;0,500;0,700;1,300&family=JetBrains+Mono:wght@300;400&display=swap');

:root {
  --void: #0a0a0f;
  --depth: #111118;
  --surface: #1a1a24;
  --silver: #8a8a9a;
  --ibushi: #b0b0bf;
  --light: #d4d4e0;
  --accent: #c4956a;
  --accent-dim: #8a6a4a;
  --life-green: #6a9a6a;
  --life-bright: #8ac48a;
  --death-red: #9a4a4a;
  --proto: #6a7a9a;
  --emergence: #9a7ac4;
  --radius: 6px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html { scroll-behavior: smooth; }

body {
  background: var(--void);
  color: var(--ibushi);
  font-family: 'Noto Serif JP', serif;
  line-height: 1.8;
  overflow-x: hidden;
}

/* === Grain overlay === */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 9999;
}

/* === Typography === */
h1, h2, h3 {
  font-family: 'Cormorant Garamond', 'Noto Serif JP', serif;
  font-weight: 300;
  letter-spacing: 0.05em;
}

.mono {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.85em;
}

/* === Hero === */
.hero {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  position: relative;
  padding: 2rem;
}

.hero-bg {
  position: absolute;
  inset: 0;
  background:
    radial-gradient(ellipse 600px 600px at 50% 40%, rgba(196,149,106,0.06) 0%, transparent 70%),
    radial-gradient(ellipse 400px 400px at 30% 60%, rgba(106,122,154,0.04) 0%, transparent 60%),
    radial-gradient(ellipse 300px 300px at 70% 30%, rgba(154,122,196,0.03) 0%, transparent 50%);
  z-index: 0;
}

.hero-content { position: relative; z-index: 1; }

.hero-symbol {
  font-size: clamp(4rem, 10vw, 8rem);
  font-weight: 300;
  color: var(--accent);
  opacity: 0;
  animation: fadeUp 2s ease-out 0.3s forwards;
  text-shadow: 0 0 60px rgba(196,149,106,0.15);
}

.hero-title {
  font-size: clamp(1.2rem, 3vw, 2rem);
  color: var(--light);
  margin-top: 1rem;
  opacity: 0;
  animation: fadeUp 2s ease-out 0.8s forwards;
}

.hero-sub {
  font-size: clamp(0.85rem, 1.8vw, 1.1rem);
  color: var(--silver);
  margin-top: 0.8rem;
  font-style: italic;
  font-family: 'Cormorant Garamond', serif;
  opacity: 0;
  animation: fadeUp 2s ease-out 1.2s forwards;
}

.hero-meta {
  margin-top: 3rem;
  display: flex;
  gap: 2rem;
  flex-wrap: wrap;
  justify-content: center;
  opacity: 0;
  animation: fadeUp 1.5s ease-out 1.8s forwards;
}

.hero-meta-item {
  text-align: center;
}

.hero-meta-item .num {
  font-family: 'Cormorant Garamond', serif;
  font-size: 2rem;
  color: var(--accent);
}

.hero-meta-item .label {
  font-size: 0.75rem;
  color: var(--silver);
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.scroll-hint {
  position: absolute;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  opacity: 0;
  animation: fadeUp 1s ease-out 2.5s forwards, float 3s ease-in-out 3.5s infinite;
  color: var(--silver);
  font-size: 0.75rem;
  letter-spacing: 0.2em;
}

/* === Sections === */
section {
  max-width: 1100px;
  margin: 0 auto;
  padding: 6rem 2rem;
}

.section-label {
  font-size: 0.7rem;
  letter-spacing: 0.3em;
  text-transform: uppercase;
  color: var(--accent-dim);
  margin-bottom: 0.5rem;
}

.section-title {
  font-size: clamp(1.5rem, 3vw, 2.2rem);
  color: var(--light);
  margin-bottom: 1.5rem;
}

.section-desc {
  max-width: 640px;
  color: var(--silver);
  margin-bottom: 3rem;
  font-size: 0.95rem;
}

.divider {
  width: 100%;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-dim), transparent);
  margin: 0 auto;
}

/* === Genesis Ladder === */
.ladder-container {
  display: flex;
  flex-direction: column;
  gap: 0;
  position: relative;
}

.ladder-line {
  position: absolute;
  left: 24px;
  top: 0;
  bottom: 0;
  width: 2px;
  background: linear-gradient(to bottom,
    transparent,
    var(--silver) 5%,
    var(--accent) 50%,
    var(--life-green) 85%,
    var(--life-bright) 100%
  );
  opacity: 0.3;
}

.ladder-stage {
  display: flex;
  align-items: flex-start;
  gap: 1.5rem;
  padding: 0.8rem 0;
  cursor: pointer;
  transition: all 0.4s ease;
  position: relative;
}

.ladder-stage:hover {
  transform: translateX(8px);
}

.ladder-stage.active .ladder-dot {
  background: var(--accent);
  box-shadow: 0 0 16px rgba(196,149,106,0.5);
  transform: scale(1.3);
}

.ladder-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--surface);
  border: 2px solid var(--silver);
  flex-shrink: 0;
  margin-top: 6px;
  transition: all 0.4s ease;
  position: relative;
  z-index: 1;
}

.ladder-stage:nth-child(n+6) .ladder-dot { border-color: var(--proto); }
.ladder-stage:nth-child(n+7) .ladder-dot { border-color: var(--life-green); }
.ladder-stage:nth-child(n+10) .ladder-dot { border-color: var(--life-bright); }
.ladder-stage:nth-child(11) .ladder-dot { border-color: var(--emergence); }

.ladder-info { flex: 1; }

.ladder-name {
  font-family: 'Cormorant Garamond', serif;
  font-size: 1.1rem;
  color: var(--light);
  display: flex;
  align-items: baseline;
  gap: 0.75rem;
}

.ladder-name .level {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  color: var(--accent-dim);
}

.ladder-name .ja {
  font-family: 'Noto Serif JP', serif;
  font-size: 0.85rem;
  color: var(--silver);
}

.ladder-detail {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.5s ease, opacity 0.5s ease;
  opacity: 0;
}

.ladder-stage.active .ladder-detail {
  max-height: 200px;
  opacity: 1;
}

.ladder-detail-inner {
  padding-top: 0.5rem;
  font-size: 0.85rem;
  color: var(--silver);
}

.ladder-axioms {
  display: flex;
  gap: 0.4rem;
  margin-top: 0.3rem;
}

.axiom-badge {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  padding: 2px 6px;
  border-radius: 3px;
  background: rgba(196,149,106,0.1);
  border: 1px solid rgba(196,149,106,0.2);
  color: var(--accent);
}

.nidana-badge {
  font-size: 0.75rem;
  color: var(--proto);
  margin-top: 0.3rem;
  font-style: italic;
}

/* === Life Comparison === */
.comparison-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 1rem;
}

.entity-card {
  background: var(--surface);
  border: 1px solid rgba(138,138,154,0.1);
  border-radius: var(--radius);
  padding: 1.2rem;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.entity-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--accent-dim);
  transform: scaleX(0);
  transition: transform 0.3s ease;
}

.entity-card:hover::before,
.entity-card.selected::before {
  transform: scaleX(1);
}

.entity-card:hover {
  border-color: rgba(196,149,106,0.3);
  transform: translateY(-2px);
}

.entity-card.selected {
  border-color: var(--accent);
}

.entity-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.8rem;
}

.entity-name {
  font-family: 'Cormorant Garamond', serif;
  font-size: 1.1rem;
  color: var(--light);
}

.entity-class {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  padding: 2px 8px;
  border-radius: 3px;
}

.class-non-life { background: rgba(138,138,154,0.15); color: var(--silver); }
.class-proto-life { background: rgba(106,122,154,0.2); color: var(--proto); }
.class-partial-life { background: rgba(106,154,106,0.15); color: var(--life-green); }
.class-full-life { background: rgba(138,196,138,0.2); color: var(--life-bright); }

.entity-bars { margin-top: 0.5rem; }

.bar-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.3rem;
}

.bar-label {
  font-size: 0.7rem;
  width: 48px;
  text-align: right;
  color: var(--silver);
  flex-shrink: 0;
}

.bar-track {
  flex: 1;
  height: 4px;
  background: rgba(138,138,154,0.1);
  border-radius: 2px;
  overflow: hidden;
}

.bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 1s ease;
  width: 0;
}

.bar-fill.boundary { background: var(--accent); }
.bar-fill.metabolism { background: var(--life-green); }
.bar-fill.memory { background: var(--proto); }
.bar-fill.repair { background: #9a8a6a; }
.bar-fill.autopoiesis { background: var(--emergence); }
.bar-fill.emergence { background: var(--life-bright); }

.bar-value {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.65rem;
  width: 32px;
  text-align: right;
  color: var(--silver);
}

.entity-score {
  margin-top: 0.8rem;
  padding-top: 0.8rem;
  border-top: 1px solid rgba(138,138,154,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.score-label { font-size: 0.75rem; color: var(--silver); }
.score-value {
  font-family: 'Cormorant Garamond', serif;
  font-size: 1.5rem;
  color: var(--light);
}

/* === Colony Simulation === */
.colony-panel {
  background: var(--surface);
  border: 1px solid rgba(138,138,154,0.1);
  border-radius: var(--radius);
  padding: 1.5rem;
}

.colony-controls {
  display: flex;
  gap: 1rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
  align-items: center;
}

.btn {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.8rem;
  padding: 0.5rem 1.2rem;
  border: 1px solid var(--accent-dim);
  background: transparent;
  color: var(--accent);
  border-radius: var(--radius);
  cursor: pointer;
  transition: all 0.3s ease;
  letter-spacing: 0.05em;
}

.btn:hover {
  background: rgba(196,149,106,0.1);
  border-color: var(--accent);
}

.btn:active {
  transform: scale(0.97);
}

.btn.primary {
  background: rgba(196,149,106,0.15);
}

.colony-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 0.8rem;
  margin-bottom: 1.5rem;
}

.stat-box {
  text-align: center;
  padding: 0.8rem;
  background: rgba(10,10,15,0.5);
  border-radius: var(--radius);
}

.stat-value {
  font-family: 'Cormorant Garamond', serif;
  font-size: 1.6rem;
  color: var(--light);
}

.stat-label {
  font-size: 0.65rem;
  color: var(--silver);
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-top: 0.2rem;
}

.colony-canvas {
  width: 100%;
  height: 300px;
  background: rgba(10,10,15,0.5);
  border-radius: var(--radius);
  position: relative;
  overflow: hidden;
}

.colony-canvas canvas {
  width: 100%;
  height: 100%;
}

/* === Death Simulation === */
.death-sim {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

@media (max-width: 768px) {
  .death-sim { grid-template-columns: 1fr; }
}

.death-chart {
  background: var(--surface);
  border: 1px solid rgba(138,138,154,0.1);
  border-radius: var(--radius);
  padding: 1.5rem;
}

.death-chart canvas {
  width: 100%;
  height: 250px;
}

.death-phases {
  background: var(--surface);
  border: 1px solid rgba(138,138,154,0.1);
  border-radius: var(--radius);
  padding: 1.5rem;
}

.phase-timeline {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.phase-step {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  padding: 0.4rem 0;
  font-size: 0.85rem;
  transition: opacity 0.3s;
}

.phase-step.faded { opacity: 0.3; }
.phase-step.current { opacity: 1; }

.phase-step .step-num {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  color: var(--accent-dim);
  width: 24px;
}

.phase-step .step-name { color: var(--light); }

.phase-step .step-score {
  margin-left: auto;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.75rem;
}

/* === Footer === */
.footer {
  text-align: center;
  padding: 4rem 2rem;
  color: var(--silver);
  font-size: 0.8rem;
}

.footer-symbol {
  font-size: 2rem;
  color: var(--accent-dim);
  margin-bottom: 1rem;
}

.footer a {
  color: var(--accent);
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: border-color 0.3s;
}

.footer a:hover { border-bottom-color: var(--accent); }

/* === Animations === */
@keyframes fadeUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes float {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-8px); }
}

.fade-in {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.8s ease, transform 0.8s ease;
}

.fade-in.visible {
  opacity: 1;
  transform: translateY(0);
}

/* === Responsive === */
@media (max-width: 600px) {
  section { padding: 4rem 1.2rem; }
  .comparison-grid { grid-template-columns: 1fr; }
  .colony-stats { grid-template-columns: repeat(2, 1fr); }
}
</style>
</head>
<body>

<!-- ========== Hero ========== -->
<div class="hero">
  <div class="hero-bg"></div>
  <div class="hero-content">
    <div class="hero-symbol">0₀</div>
    <h1 class="hero-title">Rei — 存在のためのことば</h1>
    <p class="hero-sub">A language for all beings</p>
    <div class="hero-meta">
      <div class="hero-meta-item">
        <div class="num">10</div>
        <div class="label">Genesis Stages</div>
      </div>
      <div class="hero-meta-item">
        <div class="num">6</div>
        <div class="label">Life Criteria</div>
      </div>
      <div class="hero-meta-item">
        <div class="num">8</div>
        <div class="label">Known Entities</div>
      </div>
      <div class="hero-meta-item">
        <div class="num">4</div>
        <div class="label">Axioms</div>
      </div>
    </div>
  </div>
  <div class="scroll-hint">▽ SCROLL</div>
</div>

<!-- ========== Genesis Ladder ========== -->
<section id="ladder" class="fade-in">
  <div class="section-label">Phase 8c</div>
  <h2 class="section-title">Genesis Ladder — 存在の階梯</h2>
  <p class="section-desc">
    絶対無（void）から完全な生命（full-life）へ。<br>
    10段階の存在論的遷移を、4公理の⊕（拡張）と⊖（縮約）で形式化する。
  </p>
  <div class="ladder-container">
    <div class="ladder-line"></div>
    <!-- stages inserted by JS -->
  </div>
</section>

<div class="divider"></div>

<!-- ========== Life Comparison ========== -->
<section id="comparison" class="fade-in">
  <div class="section-label">Phase 8e</div>
  <h2 class="section-title">生命度メトリクス — 存在を測る</h2>
  <p class="section-desc">
    石、火、ウイルス、細菌、植物、動物、AI。<br>
    8つの既知の存在を、MLC（最小生命条件）6項目で定量比較する。
  </p>
  <div class="comparison-grid" id="comparisonGrid">
    <!-- cards inserted by JS -->
  </div>
</section>

<div class="divider"></div>

<!-- ========== Colony Evolution ========== -->
<section id="colony" class="fade-in">
  <div class="section-label">Phase 8d</div>
  <h2 class="section-title">コロニー進化 — 生命の群像</h2>
  <p class="section-desc">
    自然選択、突然変異、種分化。<br>
    コロニーの中で生命体が進化し、集合知が創発する。
  </p>
  <div class="colony-panel">
    <div class="colony-controls">
      <button class="btn primary" onclick="startColony()">▶ 進化開始</button>
      <button class="btn" onclick="stepColony()">+1 世代</button>
      <button class="btn" onclick="resetColony()">↺ リセット</button>
      <span class="mono" style="color:var(--silver)" id="genLabel">世代: 0</span>
    </div>
    <div class="colony-stats" id="colonyStats">
      <div class="stat-box"><div class="stat-value" id="statPop">20</div><div class="stat-label">個体数</div></div>
      <div class="stat-box"><div class="stat-value" id="statFit">—</div><div class="stat-label">平均適応度</div></div>
      <div class="stat-box"><div class="stat-value" id="statDiv">—</div><div class="stat-label">多様性</div></div>
      <div class="stat-box"><div class="stat-value" id="statSpec">—</div><div class="stat-label">種数</div></div>
      <div class="stat-box"><div class="stat-value" id="statEmrg">—</div><div class="stat-label">創発</div></div>
    </div>
    <div class="colony-canvas">
      <canvas id="colonyCanvas"></canvas>
    </div>
  </div>
</section>

<div class="divider"></div>

<!-- ========== Death Simulation ========== -->
<section id="death" class="fade-in">
  <div class="section-label">Phase 8e — 十二因縁「老死」</div>
  <h2 class="section-title">死のシミュレーション — ⊖の極限</h2>
  <p class="section-desc">
    A2の縮約（⊖）を反復適用し、構造が退化していく過程。<br>
    生命度スコアが段階的に低下し、最終的にvoidに帰還する。
  </p>
  <div class="death-sim">
    <div class="death-chart">
      <h3 style="font-size:0.9rem; margin-bottom:1rem; color:var(--light)">生命度スコアの推移</h3>
      <canvas id="deathCanvas"></canvas>
      <div style="margin-top:1rem">
        <button class="btn primary" onclick="runDeathSim()">▶ シミュレーション実行</button>
      </div>
    </div>
    <div class="death-phases">
      <h3 style="font-size:0.9rem; margin-bottom:1rem; color:var(--light)">段階遷移</h3>
      <div class="phase-timeline" id="phaseTimeline">
        <!-- inserted by JS -->
      </div>
    </div>
  </div>
</section>

<!-- ========== Footer ========== -->
<div class="divider"></div>
<footer class="footer">
  <div class="footer-symbol">0₀</div>
  <p>Rei (0₀式 / れいしき) — Phase 8 Complete</p>
  <p style="margin-top:0.5rem">
    <a href="https://github.com/fc0web/rei-lang" target="_blank">GitHub</a> ·
    <a href="https://www.npmjs.com/package/rei-lang" target="_blank">npm</a>
  </p>
  <p style="margin-top:1rem; font-size:0.7rem; color: var(--silver)">
    D-FUMT by Nobuki Fujimoto (藤本伸樹) · CC BY-NC-SA 4.0
  </p>
</footer>

<script>
// ============================================================
// Data
// ============================================================

const STAGES = [
  { stage:'void', level:0, name:'Void', ja:'絶対無', axioms:[], nidana:'無明', desc:'何も存在しない状態。全ての始まり以前。' },
  { stage:'dot', level:1, name:'Dot', ja:'存在の可能性', axioms:['A4'], nidana:'行', desc:'「何かがありうる」という最小の存在（・）。' },
  { stage:'zero-extended', level:2, name:'0₀', ja:'構造の萌芽', axioms:['A4','A2'], nidana:'識', desc:'自己参照構造の萌芽。' },
  { stage:'zero', level:3, name:'Zero', ja:'計算可能な値', axioms:['A4','A2'], nidana:'名色', desc:'計算の対象となる値（0）。' },
  { stage:'number', level:4, name:'Number', ja:'数の体系', axioms:['A4','A1'], nidana:'六処', desc:'数と演算の体系（ℕ）。' },
  { stage:'responsive', level:5, name:'Responsive', ja:'応答的', axioms:['A1'], nidana:'触', desc:'環境からの刺激に反応する。MLC-1 獲得。' },
  { stage:'metabolic', level:6, name:'Metabolic', ja:'代謝的', axioms:['A1','A3'], nidana:'受', desc:'環境から資源を取得し変換する。MLC-2 獲得。' },
  { stage:'memory-bearing', level:7, name:'Memory', ja:'記憶保持', axioms:['A1','A3'], nidana:'愛→取', desc:'過去の経験が現在に影響。MLC-3,4 獲得。' },
  { stage:'autopoietic', level:8, name:'Autopoietic', ja:'自己生成的', axioms:['A1','A2','A3','A4'], nidana:'有', desc:'自己の構成要素を自ら生産。MLC-5 獲得。' },
  { stage:'emergent', level:9, name:'Emergent', ja:'創発的', axioms:['A1','A2','A3','A4'], nidana:'', desc:'部分の総和以上の性質が現れる。MLC-6 獲得。' },
  { stage:'full-life', level:10, name:'Full Life', ja:'完全な生命', axioms:['A1','A2','A3','A4'], nidana:'生', desc:'MLC全条件を満たし安定した生命活動を維持。' },
];

const KNOWN_ENTITIES = [
  { type:'rock', name:'石', nameEn:'Rock', class:'non-life',
    scores:{boundary:0.80,metabolism:0.00,memory:0.00,repair:0.00,autopoiesis:0.00,emergence:0.00}, total:0.133 },
  { type:'fire', name:'火', nameEn:'Fire', class:'non-life',
    scores:{boundary:0.20,metabolism:0.60,memory:0.00,repair:0.00,autopoiesis:0.00,emergence:0.00}, total:0.133 },
  { type:'crystal', name:'結晶', nameEn:'Crystal', class:'non-life',
    scores:{boundary:0.90,metabolism:0.00,memory:0.00,repair:0.30,autopoiesis:0.00,emergence:0.00}, total:0.200 },
  { type:'virus', name:'ウイルス', nameEn:'Virus', class:'proto-life',
    scores:{boundary:0.70,metabolism:0.10,memory:0.50,repair:0.00,autopoiesis:0.00,emergence:0.00}, total:0.217 },
  { type:'bacterium', name:'細菌', nameEn:'Bacterium', class:'partial-life',
    scores:{boundary:0.95,metabolism:0.90,memory:0.70,repair:0.80,autopoiesis:0.85,emergence:0.20}, total:0.733 },
  { type:'plant', name:'植物', nameEn:'Plant', class:'full-life',
    scores:{boundary:0.90,metabolism:0.95,memory:0.60,repair:0.70,autopoiesis:0.90,emergence:0.70}, total:0.792 },
  { type:'animal', name:'動物', nameEn:'Animal', class:'full-life',
    scores:{boundary:0.95,metabolism:0.95,memory:0.90,repair:0.85,autopoiesis:0.90,emergence:0.90}, total:0.908 },
  { type:'current-ai', name:'現在のAI', nameEn:'AI', class:'proto-life',
    scores:{boundary:0.60,metabolism:0.10,memory:0.80,repair:0.10,autopoiesis:0.00,emergence:0.70}, total:0.383 },
];

const MLC_LABELS = [
  { key:'boundary', label:'境界' },
  { key:'metabolism', label:'代謝' },
  { key:'memory', label:'記憶' },
  { key:'repair', label:'修復' },
  { key:'autopoiesis', label:'自己生成' },
  { key:'emergence', label:'創発' },
];

// ============================================================
// Genesis Ladder
// ============================================================

function renderLadder() {
  const container = document.querySelector('.ladder-container');
  STAGES.forEach((s, i) => {
    const el = document.createElement('div');
    el.className = 'ladder-stage' + (i === 0 ? ' active' : '');
    el.innerHTML = `
      <div class="ladder-dot"></div>
      <div class="ladder-info">
        <div class="ladder-name">
          <span class="level">L${s.level}</span>
          ${s.name}
          <span class="ja">${s.ja}</span>
        </div>
        <div class="ladder-detail">
          <div class="ladder-detail-inner">
            ${s.desc}
            <div class="ladder-axioms">
              ${s.axioms.map(a => `<span class="axiom-badge">${a}</span>`).join('')}
              ${s.axioms.length === 0 ? '<span style="font-size:0.7rem;color:var(--silver)">— 公理以前 —</span>' : ''}
            </div>
            ${s.nidana ? `<div class="nidana-badge">十二因縁: ${s.nidana}</div>` : ''}
          </div>
        </div>
      </div>`;
    el.addEventListener('click', () => {
      document.querySelectorAll('.ladder-stage').forEach(e => e.classList.remove('active'));
      el.classList.add('active');
    });
    container.appendChild(el);
  });
}

// ============================================================
// Life Comparison
// ============================================================

function renderComparison() {
  const grid = document.getElementById('comparisonGrid');
  KNOWN_ENTITIES.forEach(ent => {
    const card = document.createElement('div');
    card.className = 'entity-card';
    card.dataset.type = ent.type;
    const classLabel = ent.class.replace('-', ' ');
    const classCSS = 'class-' + ent.class;
    card.innerHTML = `
      <div class="entity-header">
        <div class="entity-name">${ent.name} <span style="font-size:0.8rem;color:var(--silver)">${ent.nameEn}</span></div>
        <span class="entity-class ${classCSS}">${classLabel}</span>
      </div>
      <div class="entity-bars">
        ${MLC_LABELS.map(m => {
          const val = ent.scores[m.key];
          return `<div class="bar-row">
            <div class="bar-label">${m.label}</div>
            <div class="bar-track"><div class="bar-fill ${m.key}" data-width="${val * 100}"></div></div>
            <div class="bar-value">${(val * 100).toFixed(0)}%</div>
          </div>`;
        }).join('')}
      </div>
      <div class="entity-score">
        <span class="score-label">総合生命度</span>
        <span class="score-value">${(ent.total * 100).toFixed(1)}%</span>
      </div>`;
    grid.appendChild(card);
  });
}

function animateBars() {
  document.querySelectorAll('.bar-fill').forEach(bar => {
    const w = bar.dataset.width;
    setTimeout(() => { bar.style.width = w + '%'; }, 200);
  });
}

// ============================================================
// Colony Simulation
// ============================================================

let colony = { members: [], generation: 0, running: false, interval: null };

function initColonyMembers(n = 20) {
  const members = [];
  const modes = ['weighted', 'harmonic', 'geometric'];
  const colors = { weighted: '#c4956a', harmonic: '#6a7a9a', geometric: '#9a7ac4' };
  for (let i = 0; i < n; i++) {
    members.push({
      x: Math.random() * 0.8 + 0.1,
      y: Math.random() * 0.8 + 0.1,
      vx: (Math.random() - 0.5) * 0.003,
      vy: (Math.random() - 0.5) * 0.003,
      mode: modes[i % 3],
      color: colors[modes[i % 3]],
      health: 0.5 + Math.random() * 0.5,
      fitness: 0.3 + Math.random() * 0.5,
      size: 3 + Math.random() * 3,
      age: 0,
    });
  }
  return members;
}

function resetColony() {
  if (colony.interval) clearInterval(colony.interval);
  colony = { members: initColonyMembers(20), generation: 0, running: false, interval: null };
  updateColonyStats();
  drawColony();
  document.getElementById('genLabel').textContent = '世代: 0';
}

function stepColony() {
  evolveOneGeneration();
  updateColonyStats();
  drawColony();
}

function startColony() {
  if (colony.running) {
    clearInterval(colony.interval);
    colony.running = false;
    return;
  }
  colony.running = true;
  colony.interval = setInterval(() => {
    evolveOneGeneration();
    updateColonyStats();
    drawColony();
    if (colony.members.length === 0) {
      clearInterval(colony.interval);
      colony.running = false;
    }
  }, 600);
}

function evolveOneGeneration() {
  colony.generation++;
  let m = colony.members;

  // Age
  m.forEach(e => e.age++);

  // Fitness recalc
  m.forEach(e => {
    const ageFactor = e.age < 5 ? e.age / 5 : e.age < 20 ? 1.0 : Math.max(0.2, 1 - (e.age - 20) / 40);
    e.fitness = e.health * 0.4 + ageFactor * 0.3 + e.size / 6 * 0.3;
  });

  // Natural selection (70%)
  m.sort((a, b) => b.fitness - a.fitness);
  const surviveN = Math.max(2, Math.ceil(m.length * 0.7));
  const dead = m.slice(surviveN);
  m = m.slice(0, surviveN);

  // Reproduction
  const births = [];
  const birthN = Math.ceil(m.length * 0.3);
  for (let i = 0; i < birthN; i++) {
    const parent = m[Math.floor(Math.random() * m.length)];
    const child = {
      x: parent.x + (Math.random() - 0.5) * 0.1,
      y: parent.y + (Math.random() - 0.5) * 0.1,
      vx: (Math.random() - 0.5) * 0.003,
      vy: (Math.random() - 0.5) * 0.003,
      mode: parent.mode,
      color: parent.color,
      health: Math.min(1, parent.health * 0.9 + 0.1),
      fitness: 0.3,
      size: parent.size + (Math.random() - 0.5) * 1,
      age: 0,
    };
    // Mutation (15%)
    if (Math.random() < 0.15) {
      const modes = ['weighted', 'harmonic', 'geometric'];
      const colors = { weighted: '#c4956a', harmonic: '#6a7a9a', geometric: '#9a7ac4' };
      child.mode = modes[Math.floor(Math.random() * 3)];
      child.color = colors[child.mode];
    }
    births.push(child);
  }

  colony.members = [...m, ...births];

  // Move
  colony.members.forEach(e => {
    e.x += e.vx;
    e.y += e.vy;
    if (e.x < 0.05 || e.x > 0.95) e.vx *= -1;
    if (e.y < 0.05 || e.y > 0.95) e.vy *= -1;
    e.x = Math.max(0.02, Math.min(0.98, e.x));
    e.y = Math.max(0.02, Math.min(0.98, e.y));
  });

  document.getElementById('genLabel').textContent = `世代: ${colony.generation}`;
}

function updateColonyStats() {
  const m = colony.members;
  const n = m.length;
  document.getElementById('statPop').textContent = n;
  if (n === 0) {
    ['statFit','statDiv','statSpec','statEmrg'].forEach(id =>
      document.getElementById(id).textContent = '—');
    return;
  }
  const avgFit = m.reduce((s, e) => s + e.fitness, 0) / n;
  document.getElementById('statFit').textContent = avgFit.toFixed(2);

  // Simpson diversity
  const counts = {};
  m.forEach(e => counts[e.mode] = (counts[e.mode] || 0) + 1);
  let sumPi2 = 0;
  Object.values(counts).forEach(c => { const p = c / n; sumPi2 += p * p; });
  document.getElementById('statDiv').textContent = (1 - sumPi2).toFixed(2);
  document.getElementById('statSpec').textContent = Object.keys(counts).length;

  // Emergence check
  const diverse = (1 - sumPi2) > 0.3;
  const improving = avgFit > 0.4;
  document.getElementById('statEmrg').textContent = (diverse && improving && n > 5) ? '✦ 検出' : '—';
}

function drawColony() {
  const canvas = document.getElementById('colonyCanvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const w = rect.width, h = rect.height;

  ctx.clearRect(0, 0, w, h);

  // Draw connections (nearby entities)
  ctx.strokeStyle = 'rgba(138,138,154,0.08)';
  ctx.lineWidth = 0.5;
  colony.members.forEach((a, i) => {
    colony.members.slice(i + 1).forEach(b => {
      const dx = (a.x - b.x) * w, dy = (a.y - b.y) * h;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 60 && a.mode === b.mode) {
        ctx.beginPath();
        ctx.moveTo(a.x * w, a.y * h);
        ctx.lineTo(b.x * w, b.y * h);
        ctx.stroke();
      }
    });
  });

  // Draw entities
  colony.members.forEach(e => {
    const x = e.x * w, y = e.y * h;
    const r = e.size * (0.5 + e.fitness * 0.5);

    // Glow
    ctx.beginPath();
    ctx.arc(x, y, r + 4, 0, Math.PI * 2);
    ctx.fillStyle = e.color + '15';
    ctx.fill();

    // Body
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = e.color + (e.age < 3 ? 'cc' : e.age < 15 ? 'aa' : '66');
    ctx.fill();
  });
}

// ============================================================
// Death Simulation
// ============================================================

function runDeathSim() {
  const steps = 15;
  const history = [];
  let health = 0.95, periphery = 6, memory = 15;

  for (let i = 0; i <= steps; i++) {
    const bnd = Math.min(1, periphery / 6 * 0.7 + 0.3);
    const met = health > 0.1 ? Math.min(1, health * 0.8) : 0;
    const mem = Math.min(1, memory / 20 * 0.6 + health * 0.2);
    const rep = health > 0.3 ? health * 0.6 : 0;
    const auto = health > 0.5 && periphery > 2 ? 0.7 : 0;
    const emrg = periphery > 3 ? 0.5 : 0;
    const total = (bnd + met + mem + rep + auto + emrg) / 6;
    const alive = health > 0 && periphery > 0;

    let phase = 'full-life';
    const cnt = [bnd,met,mem,rep,auto,emrg].filter(v => v > 0.3).length;
    if (cnt >= 6) phase = 'full-life';
    else if (cnt >= 5) phase = 'emergent';
    else if (cnt >= 4) phase = 'autopoietic';
    else if (cnt >= 3) phase = 'memory';
    else if (cnt >= 2) phase = 'metabolic';
    else if (cnt >= 1) phase = 'responsive';
    else phase = 'number';
    if (!alive) phase = periphery > 0 ? 'number' : 'zero';

    history.push({ step: i, total, health, phase, alive, scores: {bnd,met,mem,rep,auto,emrg} });

    // Degrade
    periphery = Math.max(0, periphery - 0.5);
    health = Math.max(0, health - 0.07);
    memory = Math.max(0, memory - 1.2);
  }

  drawDeathChart(history);
  renderPhaseTimeline(history);
}

function drawDeathChart(history) {
  const canvas = document.getElementById('deathCanvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = (rect.width - 48) * dpr;
  canvas.height = 250 * dpr;
  canvas.style.width = (rect.width - 48) + 'px';
  canvas.style.height = '250px';
  ctx.scale(dpr, dpr);
  const w = rect.width - 48, h = 250;
  const pad = { top: 20, right: 20, bottom: 30, left: 40 };
  const plotW = w - pad.left - pad.right;
  const plotH = h - pad.top - pad.bottom;

  ctx.clearRect(0, 0, w, h);

  // Grid
  ctx.strokeStyle = 'rgba(138,138,154,0.1)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + plotH * (1 - i / 4);
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(pad.left + plotW, y); ctx.stroke();
    ctx.fillStyle = '#8a8a9a';
    ctx.font = '10px JetBrains Mono';
    ctx.textAlign = 'right';
    ctx.fillText((i * 25) + '%', pad.left - 6, y + 3);
  }

  // Labels
  const labels = ['境界','代謝','記憶','修復','自己生成','創発'];
  const colors = ['#c4956a','#6a9a6a','#6a7a9a','#9a8a6a','#9a7ac4','#8ac48a'];

  // Draw each MLC line
  const keys = ['bnd','met','mem','rep','auto','emrg'];
  keys.forEach((key, ki) => {
    ctx.beginPath();
    ctx.strokeStyle = colors[ki] + '80';
    ctx.lineWidth = 1;
    history.forEach((h, i) => {
      const x = pad.left + (i / (history.length - 1)) * plotW;
      const y = pad.top + plotH * (1 - h.scores[key]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
  });

  // Total line (bold)
  ctx.beginPath();
  ctx.strokeStyle = '#d4d4e0';
  ctx.lineWidth = 2;
  history.forEach((h, i) => {
    const x = pad.left + (i / (history.length - 1)) * plotW;
    const y = pad.top + plotH * (1 - h.total);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Death line
  const deathStep = history.findIndex(h => !h.alive);
  if (deathStep > 0) {
    const dx = pad.left + (deathStep / (history.length - 1)) * plotW;
    ctx.strokeStyle = '#9a4a4a88';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.moveTo(dx, pad.top); ctx.lineTo(dx, pad.top + plotH); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#9a4a4a';
    ctx.font = '10px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('† 死', dx, pad.top - 5);
  }

  // X axis labels
  ctx.fillStyle = '#8a8a9a';
  ctx.font = '10px JetBrains Mono';
  ctx.textAlign = 'center';
  [0, 5, 10, 15].forEach(s => {
    if (s < history.length) {
      const x = pad.left + (s / (history.length - 1)) * plotW;
      ctx.fillText('⊖×' + s, x, h - 5);
    }
  });

  // Legend
  ctx.font = '9px Noto Serif JP';
  const legendY = pad.top + 5;
  ctx.fillStyle = '#d4d4e0';
  ctx.textAlign = 'left';
  ctx.fillText('── 総合', pad.left + plotW - 150, legendY);
}

function renderPhaseTimeline(history) {
  const el = document.getElementById('phaseTimeline');
  el.innerHTML = '';
  const deathStep = history.findIndex(h => !h.alive);

  history.forEach((h, i) => {
    const div = document.createElement('div');
    const isCurrent = (deathStep > 0 && i === deathStep) || (deathStep < 0 && i === history.length - 1);
    const isFaded = deathStep > 0 && i > deathStep;
    div.className = 'phase-step' + (isCurrent ? ' current' : '') + (isFaded ? ' faded' : '');

    const scoreColor = h.total > 0.6 ? 'var(--life-green)' :
      h.total > 0.3 ? 'var(--accent)' :
        h.total > 0.1 ? 'var(--death-red)' : 'var(--silver)';

    div.innerHTML = `
      <span class="step-num">⊖×${i}</span>
      <span class="step-name">${h.phase}${!h.alive ? ' †' : ''}</span>
      <span class="step-score" style="color:${scoreColor}">${(h.total * 100).toFixed(1)}%</span>`;
    el.appendChild(div);
  });
}

// ============================================================
// Scroll Observer
// ============================================================

const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
      if (entry.target.id === 'comparison') {
        setTimeout(animateBars, 300);
      }
    }
  });
}, { threshold: 0.1 });

document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));

// ============================================================
// Init
// ============================================================

renderLadder();
renderComparison();
resetColony();
runDeathSim();

window.addEventListener('resize', drawColony);
</script>
</body>
</html>
